//===- TableGen'erated file -------------------------------------*- C++ -*-===//
//
// Assembly Writer Source Fragment
//
// Automatically generated file, do not edit!
//
//===----------------------------------------------------------------------===//

/// printInstruction - This method is automatically generated by tablegen
/// from the instruction set description.  This method returns true if the
/// machine instruction was sufficiently described to print it, otherwise
/// it returns false.
bool IA64AsmPrinter::printInstruction(const MachineInstr *MI) {
  static const unsigned OpInfo[] = {
    2U,	// PHI
    0U,	// INLINEASM
    0U,	// DBG_LABEL
    0U,	// EH_LABEL
    0U,	// GC_LABEL
    0U,	// DECLARE
    0U,	// EXTRACT_SUBREG
    0U,	// INSERT_SUBREG
    0U,	// IMPLICIT_DEF
    0U,	// SUBREG_TO_REG
    536870923U,	// ADD
    536887307U,	// ADD1
    537919504U,	// ADDIMM14
    538968075U,	// ADDIMM22
    540016662U,	// ADDL_EA
    541065238U,	// ADDL_GA
    537919504U,	// ADDS
    28U,	// ADJUSTCALLSTACKDOWN
    52U,	// ADJUSTCALLSTACKUP
    553648202U,	// ALLOC
    536870993U,	// AND
    536870998U,	// ANDCM
    570425437U,	// BCMPEQ
    1073741925U,	// BRCALL
    587202661U,	// BRCALL_INDIRECT
    1073741925U,	// BRCALL_IPREL_ES
    1073741925U,	// BRCALL_IPREL_GA
    603979896U,	// BRCOND_CALL
    620757112U,	// BRCOND_NOTCALL
    637534328U,	// BRLCOND_CALL
    654311544U,	// BRLCOND_NOTCALL
    587202682U,	// BRL_NOTCALL
    1745092728U,	// CADDIMM22
    2298511480U,	// CFMADS0
    2315255928U,	// CFMADS1
    2332065912U,	// CFMAS1
    1817444472U,	// CFMOV
    2365587576U,	// CFNMADS1
    2382364792U,	// CFNMAS1
    1817444472U,	// CMOV
    788529245U,	// CMPEQ
    788529294U,	// CMPGE
    788529302U,	// CMPGEU
    788529311U,	// CMPGT
    788529319U,	// CMPGTU
    788529328U,	// CMPLE
    788529336U,	// CMPLEU
    788529345U,	// CMPLT
    788529353U,	// CMPLTU
    788529362U,	// CMPNE
    536903898U,	// DEPZ
    536903905U,	// EXTRU
    537133289U,	// FABS
    536871151U,	// FADD
    536871157U,	// FADDS
    788529405U,	// FCMPEQ
    788529414U,	// FCMPGE
    788529414U,	// FCMPGEU
    788529423U,	// FCMPGT
    788529423U,	// FCMPGTU
    788529432U,	// FCMPLE
    788529432U,	// FCMPLEU
    788529441U,	// FCMPLT
    788529441U,	// FCMPLTU
    788529450U,	// FCMPNE
    537133364U,	// FCVTFX
    537133373U,	// FCVTFXTRUNC
    537133388U,	// FCVTFXTRUNCS1
    537133406U,	// FCVTFXU
    537133416U,	// FCVTFXUTRUNC
    537133432U,	// FCVTFXUTRUNCS1
    537133451U,	// FCVTXF
    537133460U,	// FCVTXUF
    537133470U,	// FCVTXUFS1
    587202987U,	// FILL_ALL_PREDICATES_FROM_GR
    536904117U,	// FMA
    537133498U,	// FMOV
    536871359U,	// FMPY
    536904133U,	// FMS
    537133514U,	// FNEG
    537133520U,	// FNEGABS
    536904153U,	// FNMA
    537133535U,	// FNORMD
    805306856U,	// FRCPAS0
    805306866U,	// FRCPAS1
    536871420U,	// FSUB
    537133570U,	// GETFD
    537133578U,	// GETFSIG
    537133578U,	// GETFSIGD
    532U,	// IUSE
    822084125U,	// LD1
    822084130U,	// LD2
    822084135U,	// LD4
    822084140U,	// LD8
    822084145U,	// LDF4
    822084151U,	// LDF8
    822084157U,	// LDF_FILL
    536871495U,	// MIX1L
    536871503U,	// MIX1R
    536871511U,	// MIX2L
    536871519U,	// MIX2R
    536871527U,	// MIX4L
    536871535U,	// MIX4R
    537133498U,	// MOV
    543162999U,	// MOVL
    543162999U,	// MOVLIMM64
    544211386U,	// MOVSIMM14
    545259962U,	// MOVSIMM22
    536871549U,	// OR
    1912602744U,	// PCMPEQOR
    1929379960U,	// PCMPEQUNC
    2684354680U,	// PCMPEQUNCR0R0
    1956118648U,	// PCMPNE
    3422814328U,	// PFMOV
    3422814328U,	// PMOV
    537133697U,	// POPCNT
    649U,	// PSEUDO_ALLOC
    666U,	// RET
    537133743U,	// SETFD
    537133751U,	// SETFSIG
    537133751U,	// SETFSIGD
    536871617U,	// SHL
    536937158U,	// SHLADD
    536871617U,	// SHLI
    536871630U,	// SHRS
    536871630U,	// SHRSI
    536871635U,	// SHRU
    536871635U,	// SHRUI
    889192890U,	// SPILL_ALL_PREDICATES_TO_GR
    905970394U,	// ST1
    905970400U,	// ST2
    905970406U,	// ST4
    905970412U,	// ST8
    905970418U,	// STF4
    905970425U,	// STF8
    905970432U,	// STF_SPILL
    780U,	// STOP
    536871696U,	// SUB
    536888080U,	// SUB1
    547357456U,	// SUBIMM8
    537133845U,	// SXT1
    537133851U,	// SXT2
    537133857U,	// SXT4
    3914506360U,	// TCFMADS0
    3948060792U,	// TCFMAS1
    793903314U,	// TCMPNE
    1756364920U,	// TPCADDIMM22
    1996488824U,	// TPCADDS
    2560360568U,	// TPCMPEQ
    2454847608U,	// TPCMPEQOR
    3636461688U,	// TPCMPEQR0R0
    2496659576U,	// TPCMPIMM8NE
    2493251704U,	// TPCMPNE
    3569352824U,	// TPCMPNER0R0
    536904487U,	// XMAHD
    536904494U,	// XMAHUD
    536904502U,	// XMAL
    536904502U,	// XMALD
    536871741U,	// XOR
    537133890U,	// ZXT1
    537133896U,	// ZXT2
    537133902U,	// ZXT4
    2030043256U,	// pOR
    0U
  };

  const char *AsmStrs = 
    "\000\000PHINODE\n\000add \000adds \000addl \000// ADJUSTCALLSTACKDOWN\n"
    "\000// ADJUSTCALLSTACKUP\n\000alloc \000and \000andcm \000cmp.eq \000br"
    ".call.sptk rp = \000(\000(p0) brl.cond.sptk \000cmp.ge \000cmp.geu \000"
    "cmp.gt \000cmp.gtu \000cmp.le \000cmp.leu \000cmp.lt \000cmp.ltu \000cm"
    "p.ne \000dep.z \000extr.u \000fabs \000fadd \000fadd.s \000fcmp.eq \000"
    "fcmp.ge \000fcmp.gt \000fcmp.le \000fcmp.lt \000fcmp.neq \000fcvt.fx \000"
    "fcvt.fx.trunc \000fcvt.fx.trunc.s1 \000fcvt.fxu \000fcvt.fxu.trunc \000"
    "fcvt.fxu.trunc.s1 \000fcvt.xf \000fcvt.xuf \000fcvt.xuf.s1 \000mov pr ="
    " \000fma \000mov \000fmpy \000fms \000fneg \000fnegabs \000fnma \000fno"
    "rm.d \000frcpa.s0 \000frcpa.s1 \000fsub \000getf.d \000getf.sig \000// "
    "IUSE\n\000ld1 \000ld2 \000ld4 \000ld8 \000ldfs \000ldfd \000ldf.fill \000"
    "mix1.l \000mix1.r \000mix2.l \000mix2.r \000mix4.l \000mix4.r \000movl "
    "\000or \000popcnt \000// PSEUDO_ALLOC\n\000br.ret.sptk.many rp\n\000set"
    "f.d \000setf.sig \000shl \000shladd \000shr \000shr.u \000st1 [\000st2 "
    "[\000st4 [\000st8 [\000stfs [\000stfd [\000stf.spill [\000;;\n\000sub \000"
    "sxt1 \000sxt2 \000sxt4 \000xma.h \000xma.hu \000xma.l \000xor \000zxt1 "
    "\000zxt2 \000zxt4 \000";

  if (MI->getOpcode() == TargetInstrInfo::INLINEASM) {
    O << "\t";
    printInlineAsm(MI);
    return true;
  } else if (MI->isLabel()) {
    printLabel(MI);
    return true;
  } else if (MI->getOpcode() == TargetInstrInfo::DECLARE) {
    printDeclare(MI);
    return true;
  } else if (MI->getOpcode() == TargetInstrInfo::IMPLICIT_DEF) {
    printImplicitDef(MI);
    return true;
  }

  O << "\t";

  // Emit the opcode for the instruction.
  unsigned Bits = OpInfo[MI->getOpcode()];
  if (Bits == 0) return false;
  O << AsmStrs+(Bits & 1023);


  // Fragment 0 encoded into 3 bits for 8 unique commands.
  switch ((Bits >> 29) & 7) {
  default:   // unreachable.
  case 0:
    return true;
    break;
  case 1:
    // ADD, ADD1, ADDIMM14, ADDIMM22, ADDL_EA, ADDL_GA, ADDS, ALLOC, AND, AND...
    printOperand(MI, 0); 
    break;
  case 2:
    // BRCALL, BRCALL_IPREL_ES, BRCALL_IPREL_GA
    printCallOperand(MI, 0); 
    O << "\n"; 
    return true;
    break;
  case 3:
    // CADDIMM22, CFMOV, CMOV, PCMPEQOR, PCMPEQUNC, PCMPNE, TPCADDIMM22, TPCA...
    printOperand(MI, 3); 
    break;
  case 4:
    // CFMADS0, CFMADS1, CFMAS1, CFNMADS1, CFNMAS1, TPCMPEQ, TPCMPEQOR, TPCMP...
    printOperand(MI, 4); 
    break;
  case 5:
    // PCMPEQUNCR0R0
    printOperand(MI, 1); 
    O << ") cmp.eq.unc "; 
    printOperand(MI, 0); 
    O << ", p0 = r0, r0\n"; 
    return true;
    break;
  case 6:
    // PFMOV, PMOV, TPCMPEQR0R0, TPCMPNER0R0
    printOperand(MI, 2); 
    break;
  case 7:
    // TCFMADS0, TCFMAS1
    printOperand(MI, 5); 
    break;
  }


  // Fragment 1 encoded into 5 bits for 26 unique commands.
  switch ((Bits >> 24) & 31) {
  default:   // unreachable.
  case 0:
    // ADD, ADD1, ADDIMM14, ADDIMM22, ADDL_EA, ADDL_GA, ADDS, AND, ANDCM, DEP...
    O << " = "; 
    break;
  case 1:
    // ALLOC
    O << " = ar.pfs,"; 
    printOperand(MI, 1); 
    O << ","; 
    printOperand(MI, 2); 
    O << ","; 
    printOperand(MI, 3); 
    O << ","; 
    printOperand(MI, 4); 
    O << "\n"; 
    return true;
    break;
  case 2:
    // BCMPEQ
    O << ", dst2 = "; 
    printOperand(MI, 2); 
    O << ", "; 
    printOperand(MI, 3); 
    O << "\n"; 
    return true;
    break;
  case 3:
    // BRCALL_INDIRECT, BRL_NOTCALL, FILL_ALL_PREDICATES_FROM_GR
    O << "\n"; 
    return true;
    break;
  case 4:
    // BRCOND_CALL
    O << ") br.cond.call.sptk "; 
    printOperand(MI, 1); 
    O << "\n"; 
    return true;
    break;
  case 5:
    // BRCOND_NOTCALL
    O << ") br.cond.sptk "; 
    printOperand(MI, 1); 
    O << "\n"; 
    return true;
    break;
  case 6:
    // BRLCOND_CALL
    O << ") brl.cond.call.sptk "; 
    printOperand(MI, 1); 
    O << "\n"; 
    return true;
    break;
  case 7:
    // BRLCOND_NOTCALL
    O << ") brl.cond.sptk "; 
    printOperand(MI, 1); 
    O << "\n"; 
    return true;
    break;
  case 8:
    // CADDIMM22, TPCADDIMM22
    O << ") add "; 
    printOperand(MI, 0); 
    O << " = "; 
    printS22ImmOperand(MI, 2); 
    O << ", "; 
    break;
  case 9:
    // CFMADS0, TCFMADS0
    O << ") fma.d.s0 "; 
    printOperand(MI, 0); 
    O << " = "; 
    break;
  case 10:
    // CFMADS1
    O << ") fma.d.s1 "; 
    printOperand(MI, 0); 
    O << " = "; 
    printOperand(MI, 1); 
    O << ", "; 
    printOperand(MI, 2); 
    O << ", "; 
    printOperand(MI, 3); 
    O << "\n"; 
    return true;
    break;
  case 11:
    // CFMAS1, TCFMAS1
    O << ") fma.s1 "; 
    printOperand(MI, 0); 
    O << " = "; 
    break;
  case 12:
    // CFMOV, CMOV, PFMOV, PMOV
    O << ") mov "; 
    printOperand(MI, 0); 
    O << " = "; 
    break;
  case 13:
    // CFNMADS1
    O << ") fnma.d.s1 "; 
    printOperand(MI, 0); 
    O << " = "; 
    printOperand(MI, 1); 
    O << ", "; 
    printOperand(MI, 2); 
    O << ", "; 
    printOperand(MI, 3); 
    O << "\n"; 
    return true;
    break;
  case 14:
    // CFNMAS1
    O << ") fnma.s1 "; 
    printOperand(MI, 0); 
    O << " = "; 
    printOperand(MI, 1); 
    O << ", "; 
    printOperand(MI, 2); 
    O << ", "; 
    printOperand(MI, 3); 
    O << "\n"; 
    return true;
    break;
  case 15:
    // CMPEQ, CMPGE, CMPGEU, CMPGT, CMPGTU, CMPLE, CMPLEU, CMPLT, CMPLTU, CMP...
    O << ", p0 = "; 
    break;
  case 16:
    // FRCPAS0, FRCPAS1
    O << ", "; 
    printOperand(MI, 1); 
    O << " = "; 
    printOperand(MI, 2); 
    O << ", "; 
    printOperand(MI, 3); 
    O << "\n"; 
    return true;
    break;
  case 17:
    // LD1, LD2, LD4, LD8, LDF4, LDF8, LDF_FILL
    O << " = ["; 
    printOperand(MI, 1); 
    O << "]\n"; 
    return true;
    break;
  case 18:
    // PCMPEQOR, TPCMPEQOR
    O << ") cmp.eq.or "; 
    printOperand(MI, 0); 
    O << ", p0 = "; 
    break;
  case 19:
    // PCMPEQUNC
    O << ") cmp.eq.unc "; 
    printOperand(MI, 0); 
    O << ", p0 = "; 
    printOperand(MI, 1); 
    O << ", "; 
    printOperand(MI, 2); 
    O << "\n"; 
    return true;
    break;
  case 20:
    // PCMPNE, TPCMPIMM8NE, TPCMPNE, TPCMPNER0R0
    O << ") cmp.ne "; 
    printOperand(MI, 0); 
    break;
  case 21:
    // SPILL_ALL_PREDICATES_TO_GR
    O << " = pr\n"; 
    return true;
    break;
  case 22:
    // ST1, ST2, ST4, ST8, STF4, STF8, STF_SPILL
    O << "] = "; 
    printOperand(MI, 1); 
    O << "\n"; 
    return true;
    break;
  case 23:
    // TPCADDS
    O << ") adds "; 
    printOperand(MI, 0); 
    O << " = "; 
    printS14ImmOperand(MI, 2); 
    O << ", "; 
    printOperand(MI, 0); 
    O << "\n"; 
    return true;
    break;
  case 24:
    // TPCMPEQ, TPCMPEQR0R0
    O << ") cmp.eq "; 
    printOperand(MI, 0); 
    break;
  case 25:
    // pOR
    O << ") or "; 
    printOperand(MI, 0); 
    O << " = "; 
    printOperand(MI, 1); 
    O << ", "; 
    printOperand(MI, 2); 
    O << "\n"; 
    return true;
    break;
  }


  // Fragment 2 encoded into 4 bits for 14 unique commands.
  switch ((Bits >> 20) & 15) {
  default:   // unreachable.
  case 0:
    // ADD, ADD1, AND, ANDCM, CADDIMM22, CFMADS0, CFMAS1, CMPEQ, CMPGE, CMPGE...
    printOperand(MI, 1); 
    break;
  case 1:
    // ADDIMM14, ADDS
    printS14ImmOperand(MI, 2); 
    O << ", "; 
    printOperand(MI, 1); 
    O << "\n"; 
    return true;
    break;
  case 2:
    // ADDIMM22
    printS22ImmOperand(MI, 2); 
    O << ", "; 
    printOperand(MI, 1); 
    O << "\n"; 
    return true;
    break;
  case 3:
    // ADDL_EA
    printCallOperand(MI, 2); 
    O << ", "; 
    printOperand(MI, 1); 
    O << "\n"; 
    return true;
    break;
  case 4:
    // ADDL_GA
    printGlobalOperand(MI, 2); 
    O << ", "; 
    printOperand(MI, 1); 
    O << "\n"; 
    return true;
    break;
  case 5:
    // CFMOV, CMOV, TCFMADS0, TCFMAS1, TCMPNE, TPCMPEQOR
    printOperand(MI, 2); 
    break;
  case 6:
    // MOVL, MOVLIMM64
    printS64ImmOperand(MI, 1); 
    O << "\n"; 
    return true;
    break;
  case 7:
    // MOVSIMM14
    printS14ImmOperand(MI, 1); 
    O << "\n"; 
    return true;
    break;
  case 8:
    // MOVSIMM22
    printS22ImmOperand(MI, 1); 
    O << "\n"; 
    return true;
    break;
  case 9:
    // PCMPNE, TPCMPEQ, TPCMPNE
    O << ", p0 = "; 
    break;
  case 10:
    // SUBIMM8
    printS8ImmOperand(MI, 1); 
    O << ", "; 
    printOperand(MI, 2); 
    O << "\n"; 
    return true;
    break;
  case 11:
    // TPCADDIMM22
    printOperand(MI, 0); 
    O << "\n"; 
    return true;
    break;
  case 12:
    // TPCMPEQR0R0, TPCMPNER0R0
    O << ", p0 = r0, r0\n"; 
    return true;
    break;
  case 13:
    // TPCMPIMM8NE
    O << " , p0 = "; 
    printS22ImmOperand(MI, 2); 
    O << ", "; 
    printOperand(MI, 3); 
    O << "\n"; 
    return true;
    break;
  }


  // Fragment 3 encoded into 2 bits for 4 unique commands.
  switch ((Bits >> 18) & 3) {
  default:   // unreachable.
  case 0:
    // ADD, ADD1, AND, ANDCM, CFMADS0, CFMAS1, CMPEQ, CMPGE, CMPGEU, CMPGT, C...
    O << ", "; 
    break;
  case 1:
    // CADDIMM22, CFMOV, CMOV, FABS, FCVTFX, FCVTFXTRUNC, FCVTFXTRUNCS1, FCVT...
    O << "\n"; 
    return true;
    break;
  case 2:
    // PCMPNE
    printOperand(MI, 1); 
    O << ", "; 
    printOperand(MI, 2); 
    O << "\n"; 
    return true;
    break;
  case 3:
    // TPCMPEQ, TPCMPNE
    printOperand(MI, 2); 
    O << ", "; 
    printOperand(MI, 3); 
    O << "\n"; 
    return true;
    break;
  }


  // Fragment 4 encoded into 2 bits for 3 unique commands.
  switch ((Bits >> 16) & 3) {
  default:   // unreachable.
  case 0:
    // ADD, ADD1, AND, ANDCM, CFMADS0, CFMAS1, CMPEQ, CMPGE, CMPGEU, CMPGT, C...
    printOperand(MI, 2); 
    break;
  case 1:
    // SHLADD
    printS64ImmOperand(MI, 2); 
    O << ", "; 
    printOperand(MI, 3); 
    O << "\n"; 
    return true;
    break;
  case 2:
    // TCFMADS0, TCFMAS1, TCMPNE, TPCMPEQOR
    printOperand(MI, 3); 
    break;
  }


  // Fragment 5 encoded into 2 bits for 3 unique commands.
  switch ((Bits >> 14) & 3) {
  default:   // unreachable.
  case 0:
    // ADD, AND, ANDCM, CMPEQ, CMPGE, CMPGEU, CMPGT, CMPGTU, CMPLE, CMPLEU, C...
    O << "\n"; 
    return true;
    break;
  case 1:
    // ADD1, SUB1
    O << ", 1\n"; 
    return true;
    break;
  case 2:
    // CFMADS0, CFMAS1, DEPZ, EXTRU, FMA, FMS, FNMA, TCFMADS0, TCFMAS1, XMAHD...
    O << ", "; 
    break;
  }


  // Fragment 6 encoded into 1 bits for 2 unique commands.
  if ((Bits >> 13) & 1) {
    // TCFMADS0, TCFMAS1
    printOperand(MI, 4); 
    O << "\n"; 
    return true;
  } else {
    // CFMADS0, CFMAS1, DEPZ, EXTRU, FMA, FMS, FNMA, XMAHD, XMAHUD, XMAL, XMA...
    printOperand(MI, 3); 
    O << "\n"; 
    return true;
  }

}
