//===- TableGen'erated file -------------------------------------*- C++ -*-===//
//
// Assembly Writer Source Fragment
//
// Automatically generated file, do not edit!
//
//===----------------------------------------------------------------------===//

/// printInstruction - This method is automatically generated by tablegen
/// from the instruction set description.  This method returns true if the
/// machine instruction was sufficiently described to print it, otherwise
/// it returns false.
bool MipsAsmPrinter::printInstruction(const MachineInstr *MI) {
  static const unsigned OpInfo[] = {
    2U,	// PHI
    0U,	// INLINEASM
    0U,	// DBG_LABEL
    0U,	// EH_LABEL
    0U,	// GC_LABEL
    0U,	// DECLARE
    0U,	// EXTRACT_SUBREG
    0U,	// INSERT_SUBREG
    0U,	// IMPLICIT_DEF
    0U,	// SUBREG_TO_REG
    536870923U,	// ADD
    536870928U,	// ADDi
    536870934U,	// ADDiu
    536870941U,	// ADDu
    1140850723U,	// ADJCALLSTACKDOWN
    1140850742U,	// ADJCALLSTACKUP
    536870983U,	// AND
    538968140U,	// ANDi
    603979858U,	// BC1F
    603979864U,	// BC1FL
    603979871U,	// BC1T
    603979877U,	// BC1TL
    536871020U,	// BEQ
    541065329U,	// BGEZ
    541065335U,	// BGEZAL
    541065343U,	// BGTZ
    541065349U,	// BLEZ
    541065355U,	// BLTZ
    541065361U,	// BLTZAL
    536871065U,	// BNE
    541065374U,	// CEIL_LD
    541065374U,	// CEIL_LS
    541065382U,	// CEIL_W_AS32
    541065392U,	// CEIL_W_D32
    541065382U,	// CEIL_W_SO32
    541065402U,	// CLZ
    603979967U,	// CPLOAD
    1207959752U,	// CPRESTORE
    541065428U,	// CVTD_L32
    541065437U,	// CVTD_S32
    541065446U,	// CVTD_W32
    541065455U,	// CVTL_D
    541065455U,	// CVTL_S
    541065462U,	// CVTS_D32
    541065471U,	// CVTS_L32
    541065480U,	// CVTS_W32
    541065489U,	// CVTW_AS32
    541065498U,	// CVTW_D32
    541065489U,	// CVTW_SO32
    541065507U,	// DIV
    541065512U,	// DIVu
    541065518U,	// FABS_AS32
    541065525U,	// FABS_D32
    541065518U,	// FABS_SO32
    536871228U,	// FADD_AS32
    536871235U,	// FADD_D32
    536871228U,	// FADD_SO32
    1811939658U,	// FCMP_AS32
    1879048522U,	// FCMP_D32
    1811939658U,	// FCMP_SO32
    536871245U,	// FDIV_AS32
    536871252U,	// FDIV_D32
    536871245U,	// FDIV_SO32
    541065563U,	// FLOOR_LD
    541065563U,	// FLOOR_LS
    541065572U,	// FLOOR_W_AS32
    541065583U,	// FLOOR_W_D32
    541065572U,	// FLOOR_W_SO32
    541065594U,	// FMOV_AS32
    541065601U,	// FMOV_D32
    541065594U,	// FMOV_SO32
    536871304U,	// FMUL_AS32
    536871311U,	// FMUL_D32
    536871304U,	// FMUL_SO32
    541065622U,	// FNEG_AS32
    541065629U,	// FNEG_D32
    541065622U,	// FNEG_SO32
    541065636U,	// FSQRT_AS32
    541065644U,	// FSQRT_D32
    541065636U,	// FSQRT_SO32
    536871348U,	// FSUB_AS32
    536871355U,	// FSUB_D32
    536871348U,	// FSUB_SO32
    603980226U,	// J
    603980229U,	// JAL
    603980234U,	// JALR
    603980240U,	// JR
    545259988U,	// LB
    545259992U,	// LBu
    545259997U,	// LDC1
    553648150U,	// LEA_ADDiu
    545260003U,	// LH
    545260007U,	// LHu
    562037228U,	// LUi
    545260017U,	// LW
    545260021U,	// LWC1
    545260021U,	// LWC1A
    507U,	// MACRO
    541065735U,	// MFC1
    541065735U,	// MFC1A
    603980301U,	// MFHI
    603980307U,	// MFLO
    570425881U,	// MOVN
    570425887U,	// MOVZ
    2147484197U,	// MTC1
    2147484197U,	// MTC1A
    603980331U,	// MTHI
    603980337U,	// MTLO
    541065783U,	// MULT
    541065789U,	// MULTu
    580U,	// NOMACRO
    594U,	// NOP
    536871511U,	// NOR
    604U,	// NOREORDER
    536871532U,	// OR
    538968688U,	// ORi
    629U,	// REORDER
    603980240U,	// RET
    541065859U,	// ROUND_LD
    541065859U,	// ROUND_LS
    541065868U,	// ROUND_W_AS32
    541065879U,	// ROUND_W_D32
    541065868U,	// ROUND_W_SO32
    545260194U,	// SB
    545260198U,	// SDC1
    541065900U,	// SEB
    541065905U,	// SEH
    545260214U,	// SH
    536871610U,	// SLL
    536871615U,	// SLLV
    536871621U,	// SLT
    536871626U,	// SLTi
    536871632U,	// SLTiu
    536871639U,	// SLTu
    536871645U,	// SRA
    536871650U,	// SRAV
    536871656U,	// SRL
    536871661U,	// SRLV
    536871667U,	// SUB
    536871672U,	// SUBu
    545260286U,	// SW
    545260290U,	// SWC1
    545260290U,	// SWC1A
    776U,	// Select_CC
    797U,	// Select_CC_AS32
    823U,	// Select_CC_D32
    848U,	// Select_CC_SO32
    874U,	// Select_FCC
    892U,	// Select_FCC_AS32
    919U,	// Select_FCC_D32
    945U,	// Select_FCC_SO32
    541066188U,	// TRUNC_LD
    541066188U,	// TRUNC_LS
    541066197U,	// TRUNC_W_AS32
    541066208U,	// TRUNC_W_D32
    541066197U,	// TRUNC_W_SO32
    541066219U,	// WSBW
    536871921U,	// XOR
    538969078U,	// XORi
    0U
  };

  const char *AsmStrs = 
    "\000\000PHINODE\n\000add\t\000addi\t\000addiu\t\000addu\t\000!ADJCALLST"
    "ACKDOWN \000!ADJCALLSTACKUP \000and\t\000andi\t\000bc1f \000bc1fl \000b"
    "c1t \000bc1tl \000beq\t\000bgez\t\000bgezal\t\000bgtz\t\000blez\t\000bl"
    "tz\t\000bltzal\t\000bne\t\000ceil.l \000ceil.w.s \000ceil.w.d \000clz\t"
    "\000.cpload\t\000.cprestore\t\000cvt.d.l \000cvt.d.s \000cvt.d.w \000cv"
    "t.l \000cvt.s.d \000cvt.s.l \000cvt.s.w \000cvt.w.s \000cvt.w.d \000div"
    "\t\000divu\t\000abs.s \000abs.d \000add.s \000add.d \000c.\000div.s \000"
    "div.d \000floor.l \000floor.w.s \000floor.w.d \000mov.s \000mov.d \000m"
    "ul.s \000mul.d \000neg.s \000neg.d \000sqrt.s \000sqrt.d \000sub.s \000"
    "sub.d \000j\t\000jal\t\000jalr\t\000jr\t\000lb\t\000lbu\t\000ldc1 \000l"
    "h\t\000lhu\t\000lui\t\000lw\t\000lwc1 \000.set\tmacro\n\000mfc1 \000mfh"
    "i\t\000mflo\t\000movn\t\000movz\t\000mtc1 \000mthi\t\000mtlo\t\000mult\t"
    "\000multu\t\000.set\tnomacro\n\000nop\n\000nor\t\000.set\tnoreorder\n\000"
    "or\t\000ori\t\000.set\treorder\n\000round.l \000round.w.s \000round.w.d"
    " \000sb\t\000sdc1 \000seb\t\000seh\t\000sh\t\000sll\t\000sllv\t\000slt\t"
    "\000slti\t\000sltiu\t\000sltu\t\000sra\t\000srav\t\000srl\t\000srlv\t\000"
    "sub\t\000subu\t\000sw\t\000swc1 \000# MipsSelect_CC_i32\n\000# MipsSele"
    "ct_CC_AS32_f32\n\000# MipsSelect_CC_D32_f32\n\000# MipsSelect_CC_SO32_f"
    "32\n\000# MipsSelect_FCC\n\000# MipsSelect_FCC_AS32_f32\n\000# MipsSele"
    "ct_FCC_D32_f32\n\000# MipsSelect_FCC_SO32_f32\n\000trunc.l \000trunc.w."
    "s \000trunc.w.d \000wsbw\t\000xor\t\000xori\t\000";

  if (MI->getOpcode() == TargetInstrInfo::INLINEASM) {
    O << "\t";
    printInlineAsm(MI);
    return true;
  } else if (MI->isLabel()) {
    printLabel(MI);
    return true;
  } else if (MI->getOpcode() == TargetInstrInfo::DECLARE) {
    printDeclare(MI);
    return true;
  } else if (MI->getOpcode() == TargetInstrInfo::IMPLICIT_DEF) {
    printImplicitDef(MI);
    return true;
  }

  O << "\t";

  // Emit the opcode for the instruction.
  unsigned Bits = OpInfo[MI->getOpcode()];
  if (Bits == 0) return false;
  O << AsmStrs+(Bits & 1023);


  // Fragment 0 encoded into 3 bits for 5 unique commands.
  switch ((Bits >> 29) & 7) {
  default:   // unreachable.
  case 0:
    return true;
    break;
  case 1:
    // ADD, ADDi, ADDiu, ADDu, AND, ANDi, BC1F, BC1FL, BC1T, BC1TL, BEQ, BGEZ...
    printOperand(MI, 0); 
    break;
  case 2:
    // ADJCALLSTACKDOWN, ADJCALLSTACKUP, CPRESTORE
    printUnsignedImm(MI, 0); 
    break;
  case 3:
    // FCMP_AS32, FCMP_D32, FCMP_SO32
    printFCCOperand(MI, 2); 
    break;
  case 4:
    // MTC1, MTC1A
    printOperand(MI, 1); 
    O << ", "; 
    printOperand(MI, 0); 
    O << "\n"; 
    return true;
    break;
  }


  // Fragment 1 encoded into 3 bits for 5 unique commands.
  switch ((Bits >> 26) & 7) {
  default:   // unreachable.
  case 0:
    // ADD, ADDi, ADDiu, ADDu, AND, ANDi, BEQ, BGEZ, BGEZAL, BGTZ, BLEZ, BLTZ...
    O << ", "; 
    break;
  case 1:
    // ADJCALLSTACKDOWN, ADJCALLSTACKUP, BC1F, BC1FL, BC1T, BC1TL, CPLOAD, J,...
    O << "\n"; 
    return true;
    break;
  case 2:
    // CPRESTORE
    O << "\n\n"; 
    return true;
    break;
  case 3:
    // FCMP_AS32, FCMP_SO32
    O << ".s "; 
    printOperand(MI, 0); 
    O << ", "; 
    printOperand(MI, 1); 
    O << "\n"; 
    return true;
    break;
  case 4:
    // FCMP_D32
    O << ".d "; 
    printOperand(MI, 0); 
    O << ", "; 
    printOperand(MI, 1); 
    O << "\n"; 
    return true;
    break;
  }


  // Fragment 2 encoded into 3 bits for 5 unique commands.
  switch ((Bits >> 23) & 7) {
  default:   // unreachable.
  case 0:
    // ADD, ADDi, ADDiu, ADDu, AND, ANDi, BEQ, BGEZ, BGEZAL, BGTZ, BLEZ, BLTZ...
    printOperand(MI, 1); 
    break;
  case 1:
    // LB, LBu, LDC1, LH, LHu, LW, LWC1, LWC1A, SB, SDC1, SH, SW, SWC1, SWC1A
    printMemOperand(MI, 1); 
    O << "\n"; 
    return true;
    break;
  case 2:
    // LEA_ADDiu
    printMemOperand(MI, 1, "stackloc"); 
    O << "\n"; 
    return true;
    break;
  case 3:
    // LUi
    printUnsignedImm(MI, 1); 
    O << "\n"; 
    return true;
    break;
  case 4:
    // MOVN, MOVZ
    printOperand(MI, 2); 
    O << ", "; 
    printOperand(MI, 3); 
    O << "\n"; 
    return true;
    break;
  }


  // Fragment 3 encoded into 1 bits for 2 unique commands.
  if ((Bits >> 22) & 1) {
    // BGEZ, BGEZAL, BGTZ, BLEZ, BLTZ, BLTZAL, CEIL_LD, CEIL_LS, CEIL_W_AS32,...
    O << "\n"; 
    return true;
  } else {
    // ADD, ADDi, ADDiu, ADDu, AND, ANDi, BEQ, BNE, FADD_AS32, FADD_D32, FADD...
    O << ", "; 
  }


  // Fragment 4 encoded into 1 bits for 2 unique commands.
  if ((Bits >> 21) & 1) {
    // ANDi, ORi, XORi
    printUnsignedImm(MI, 2); 
    O << "\n"; 
    return true;
  } else {
    // ADD, ADDi, ADDiu, ADDu, AND, BEQ, BNE, FADD_AS32, FADD_D32, FADD_SO32,...
    printOperand(MI, 2); 
    O << "\n"; 
    return true;
  }

}
