//===- TableGen'erated file -------------------------------------*- C++ -*-===//
//
// Assembly Writer Source Fragment
//
// Automatically generated file, do not edit!
//
//===----------------------------------------------------------------------===//

/// printInstruction - This method is automatically generated by tablegen
/// from the instruction set description.  This method returns true if the
/// machine instruction was sufficiently described to print it, otherwise
/// it returns false.
bool AlphaAsmPrinter::printInstruction(const MachineInstr *MI) {
  static const unsigned OpInfo[] = {
    2U,	// PHI
    0U,	// INLINEASM
    0U,	// DBG_LABEL
    0U,	// EH_LABEL
    0U,	// GC_LABEL
    0U,	// DECLARE
    0U,	// EXTRACT_SUBREG
    0U,	// INSERT_SUBREG
    0U,	// IMPLICIT_DEF
    0U,	// SUBREG_TO_REG
    1073741835U,	// ADDLi
    1073741835U,	// ADDLr
    1073741841U,	// ADDQi
    1073741841U,	// ADDQr
    1073741847U,	// ADDS
    1073741856U,	// ADDT
    2214592553U,	// ADJUSTSTACKDOWN
    2214592564U,	// ADJUSTSTACKUP
    2281701437U,	// ALTENT
    1073741887U,	// ANDi
    1073741887U,	// ANDr
    1082130500U,	// BEQ
    1082130505U,	// BGE
    1082130510U,	// BGT
    1073741907U,	// BICi
    1073741907U,	// BICr
    1073741912U,	// BISi
    1073741912U,	// BISr
    1082130525U,	// BLBC
    1082130531U,	// BLBS
    1082130537U,	// BLE
    1082130542U,	// BLT
    1082130547U,	// BNE
    2214592632U,	// BR
    2348810368U,	// BSR
    0U,	// CAS32
    0U,	// CAS64
    1073741962U,	// CMOVEQi
    1073741962U,	// CMOVEQr
    1073741970U,	// CMOVGEi
    1073741970U,	// CMOVGEr
    1073741978U,	// CMOVGTi
    1073741978U,	// CMOVGTr
    1073741986U,	// CMOVLBCi
    1073741986U,	// CMOVLBCr
    1073741995U,	// CMOVLBSi
    1073741995U,	// CMOVLBSr
    1073742004U,	// CMOVLEi
    1073742004U,	// CMOVLEr
    1073742012U,	// CMOVLTi
    1073742012U,	// CMOVLTr
    1073742020U,	// CMOVNEi
    1073742020U,	// CMOVNEr
    1073742028U,	// CMPBGE
    1073742028U,	// CMPBGEi
    1073742036U,	// CMPEQ
    1073742036U,	// CMPEQi
    1073742043U,	// CMPLE
    1073742043U,	// CMPLEi
    1073742050U,	// CMPLT
    1073742050U,	// CMPLTi
    1073742057U,	// CMPTEQ
    1073742068U,	// CMPTLE
    1073742079U,	// CMPTLT
    1073742090U,	// CMPTUN
    1073742101U,	// CMPULE
    1073742101U,	// CMPULEi
    1073742109U,	// CMPULT
    1073742109U,	// CMPULTi
    2415919397U,	// COND_BRANCH_F
    2483028261U,	// COND_BRANCH_I
    1073742143U,	// CPYSES
    1073742143U,	// CPYSESt
    1073742143U,	// CPYSET
    1073742150U,	// CPYSNS
    1073742150U,	// CPYSNSt
    1073742150U,	// CPYSNT
    1073742150U,	// CPYSNTs
    1073742157U,	// CPYSS
    1073742157U,	// CPYSSt
    1073742157U,	// CPYST
    1073742157U,	// CPYSTs
    1476395347U,	// CTLZ
    1476395353U,	// CTPOP
    1476395360U,	// CTTZ
    1476395366U,	// CVTQS
    1476395377U,	// CVTQT
    1476395388U,	// CVTST
    1476395397U,	// CVTTQ
    1476395408U,	// CVTTS
    1073742235U,	// DIVS
    1073742244U,	// DIVT
    1073742253U,	// EQVi
    1073742253U,	// EQVr
    1073742258U,	// EXTBL
    1073742265U,	// EXTLL
    1073742272U,	// EXTWL
    1082130887U,	// FBEQ
    1082130893U,	// FBGE
    1082130899U,	// FBGT
    1082130905U,	// FBLE
    1082130911U,	// FBLT
    1082130917U,	// FBNE
    3221225963U,	// FCMOVEQS
    3221225963U,	// FCMOVEQT
    3221225972U,	// FCMOVGES
    3221225972U,	// FCMOVGET
    3221225981U,	// FCMOVGTS
    3221225981U,	// FCMOVGTT
    3221225990U,	// FCMOVLES
    3221225990U,	// FCMOVLET
    3221225999U,	// FCMOVLTS
    3221225999U,	// FCMOVLTT
    3221226008U,	// FCMOVNES
    3221226008U,	// FCMOVNET
    1476395553U,	// FTOIS
    1476395560U,	// FTOIT
    1476395567U,	// ITOFS
    1476395574U,	// ITOFT
    2617246269U,	// JMP
    583U,	// JSR
    2684355160U,	// JSR_COROUTINE
    615U,	// JSRs
    0U,	// LAS32
    0U,	// LAS64
    2768241272U,	// LDA
    2768241277U,	// LDAH
    2818572925U,	// LDAHg
    2776629885U,	// LDAHr
    2818572920U,	// LDAg
    2785018488U,	// LDAr
    2768241283U,	// LDBU
    2785018499U,	// LDBUr
    2768241289U,	// LDL
    2768241294U,	// LDL_L
    2785018505U,	// LDLr
    2768241301U,	// LDQ
    2768241306U,	// LDQ_L
    2793407125U,	// LDQl
    2785018517U,	// LDQr
    2768241313U,	// LDS
    2785018529U,	// LDSr
    2768241318U,	// LDT
    2785018534U,	// LDTr
    2768241323U,	// LDWU
    2785018539U,	// LDWUr
    689U,	// MB
    2885681845U,	// MEMLABEL
    1073742527U,	// MULLi
    1073742527U,	// MULLr
    1073742533U,	// MULQi
    1073742533U,	// MULQr
    1073742539U,	// MULS
    1073742548U,	// MULT
    1073742557U,	// ORNOTi
    1073742557U,	// ORNOTr
    2952790756U,	// PCLABEL
    750U,	// RETDAG
    750U,	// RETDAGp
    2214593279U,	// RPCC
    1073742597U,	// S4ADDLi
    1073742597U,	// S4ADDLr
    1073742605U,	// S4ADDQi
    1073742605U,	// S4ADDQr
    1073742613U,	// S4SUBLi
    1073742613U,	// S4SUBLr
    1073742621U,	// S4SUBQi
    1073742621U,	// S4SUBQr
    1073742629U,	// S8ADDLi
    1073742629U,	// S8ADDLr
    1073742637U,	// S8ADDQi
    1073742637U,	// S8ADDQr
    1073742645U,	// S8SUBLi
    1073742645U,	// S8SUBLr
    1073742653U,	// S8SUBQi
    1073742653U,	// S8SUBQr
    1476395845U,	// SEXTB
    1476395852U,	// SEXTW
    1073742675U,	// SLi
    1073742675U,	// SLr
    1476395864U,	// SQRTS
    1476395874U,	// SQRTT
    1073742700U,	// SRAi
    1073742700U,	// SRAr
    1073742705U,	// SRLi
    1073742705U,	// SRLr
    2768241526U,	// STB
    2785018742U,	// STBr
    2768241531U,	// STL
    1124074368U,	// STL_C
    2785018747U,	// STLr
    2768241543U,	// STQ
    1124074380U,	// STQ_C
    2785018759U,	// STQr
    2768241555U,	// STS
    2785018771U,	// STSr
    2768241560U,	// STT
    2785018776U,	// STTr
    2768241565U,	// STW
    2785018781U,	// STWr
    1073742754U,	// SUBLi
    1073742754U,	// SUBLr
    1073742760U,	// SUBQi
    1073742760U,	// SUBQr
    1073742766U,	// SUBS
    1073742775U,	// SUBT
    0U,	// SWAP32
    0U,	// SWAP64
    1073742784U,	// UMULHi
    1073742784U,	// UMULHr
    967U,	// WMB
    972U,	// WTF
    1073742802U,	// XORi
    1073742802U,	// XORr
    1073742807U,	// ZAPNOTi
    0U
  };

  const char *AsmStrs = 
    "\000\000PHINODE\n\000addl \000addq \000adds/su \000addt/su \000; ADJDOW"
    "N \000; ADJUP \000$\000and \000beq \000bge \000bgt \000bic \000bis \000"
    "blbc \000blbs \000ble \000blt \000bne \000br $31,\000bsr $26,$\000cmove"
    "q \000cmovge \000cmovgt \000cmovlbc \000cmovlbs \000cmovle \000cmovlt \000"
    "cmovne \000cmpbge \000cmpeq \000cmple \000cmplt \000cmpteq/su \000cmptl"
    "e/su \000cmptlt/su \000cmptun/su \000cmpule \000cmpult \000:comment CON"
    "D_BRANCH imm:\000cpyse \000cpysn \000cpys \000CTLZ \000CTPOP \000CTTZ \000"
    "cvtqs/sui \000cvtqt/sui \000cvtst/s \000cvttq/svc \000cvtts/sui \000div"
    "s/su \000divt/su \000eqv \000EXTBL \000EXTLL \000EXTWL \000fbeq \000fbg"
    "e \000fbgt \000fble \000fblt \000fbne \000fcmoveq \000fcmovge \000fcmov"
    "gt \000fcmovle \000fcmovlt \000fcmovne \000ftois \000ftoit \000itofs \000"
    "itoft \000jmp $31,(\000jsr $26,($27),0\n\000jsr_coroutine \000jsr $23,("
    "$27),0\n\000lda \000ldah \000ldbu \000ldl \000ldl_l \000ldq \000ldq_l \000"
    "lds \000ldt \000ldwu \000mb\n\000LSMARKER$\000mull \000mulq \000muls/su"
    " \000mult/su \000ornot \000PCMARKER_\000ret $31,($26),1\n\000rpcc \000s"
    "4addl \000s4addq \000s4subl \000s4subq \000s8addl \000s8addq \000s8subl"
    " \000s8subq \000sextb \000sextw \000sll \000sqrts/su \000sqrtt/su \000s"
    "ra \000srl \000stb \000stl \000stl_l \000stq \000stq_l \000sts \000stt "
    "\000stw \000subl \000subq \000subs/su \000subt/su \000umulh \000wmb\n\000"
    "#wtf\n\000xor \000zapnot \000";

  if (MI->getOpcode() == TargetInstrInfo::INLINEASM) {
    O << "\t";
    printInlineAsm(MI);
    return true;
  } else if (MI->isLabel()) {
    printLabel(MI);
    return true;
  } else if (MI->getOpcode() == TargetInstrInfo::DECLARE) {
    printDeclare(MI);
    return true;
  } else if (MI->getOpcode() == TargetInstrInfo::IMPLICIT_DEF) {
    printImplicitDef(MI);
    return true;
  }

  O << "\t";

  // Emit the opcode for the instruction.
  unsigned Bits = OpInfo[MI->getOpcode()];
  if (Bits == 0) return false;
  O << AsmStrs+(Bits & 1023);


  // Fragment 0 encoded into 2 bits for 4 unique commands.
  switch ((Bits >> 30) & 3) {
  default:   // unreachable.
  case 0:
    return true;
    break;
  case 1:
    // ADDLi, ADDLr, ADDQi, ADDQr, ADDS, ADDT, ANDi, ANDr, BEQ, BGE, BGT, BIC...
    printOperand(MI, 1); 
    O << ","; 
    break;
  case 2:
    // ADJUSTSTACKDOWN, ADJUSTSTACKUP, ALTENT, BR, BSR, COND_BRANCH_F, COND_B...
    printOperand(MI, 0); 
    break;
  case 3:
    // FCMOVEQS, FCMOVEQT, FCMOVGES, FCMOVGET, FCMOVGTS, FCMOVGTT, FCMOVLES, ...
    printOperand(MI, 3); 
    O << ","; 
    printOperand(MI, 2); 
    O << ","; 
    printOperand(MI, 0); 
    O << "\n"; 
    return true;
    break;
  }


  // Fragment 1 encoded into 4 bits for 13 unique commands.
  switch ((Bits >> 26) & 15) {
  default:   // unreachable.
  case 0:
    // ADDLi, ADDLr, ADDQi, ADDQr, ADDS, ADDT, ANDi, ANDr, BEQ, BGE, BGT, BIC...
    printOperand(MI, 2); 
    break;
  case 1:
    // ADJUSTSTACKDOWN, ADJUSTSTACKUP, BR, RPCC
    O << "\n"; 
    return true;
    break;
  case 2:
    // ALTENT
    O << "..ng:\n\n"; 
    return true;
    break;
  case 3:
    // BSR
    O << "..ng\n"; 
    return true;
    break;
  case 4:
    // COND_BRANCH_F
    O << ", F8RC:"; 
    printOperand(MI, 1); 
    O << ", bb:"; 
    printOperand(MI, 2); 
    O << "\n"; 
    return true;
    break;
  case 5:
    // COND_BRANCH_I
    O << ", GPRC:"; 
    printOperand(MI, 1); 
    O << ", bb:"; 
    printOperand(MI, 2); 
    O << "\n"; 
    return true;
    break;
  case 6:
    // CTLZ, CTPOP, CTTZ, CVTQS, CVTQT, CVTST, CVTTQ, CVTTS, FTOIS, FTOIT, IT...
    printOperand(MI, 0); 
    O << "\n"; 
    return true;
    break;
  case 7:
    // JMP
    O << "),0\n"; 
    return true;
    break;
  case 8:
    // JSR_COROUTINE
    O << ",("; 
    printOperand(MI, 1); 
    O << "),"; 
    printOperand(MI, 2); 
    O << "\n"; 
    return true;
    break;
  case 9:
    // LDA, LDAH, LDAHr, LDAr, LDBU, LDBUr, LDL, LDL_L, LDLr, LDQ, LDQ_L, LDQ...
    O << ","; 
    printOperand(MI, 1); 
    O << "("; 
    printOperand(MI, 2); 
    break;
  case 10:
    // LDAHg, LDAg
    O << ",0("; 
    printOperand(MI, 2); 
    O << ")\t\t!gpdisp!"; 
    printOperand(MI, 3); 
    O << "\n"; 
    return true;
    break;
  case 11:
    // MEMLABEL
    O << "$"; 
    printOperand(MI, 1); 
    O << "$"; 
    printOperand(MI, 2); 
    O << "$"; 
    printOperand(MI, 3); 
    O << ":\n"; 
    return true;
    break;
  case 12:
    // PCLABEL
    O << ":\n\n"; 
    return true;
    break;
  }


  // Fragment 2 encoded into 3 bits for 7 unique commands.
  switch ((Bits >> 23) & 7) {
  default:   // unreachable.
  case 0:
    // ADDLi, ADDLr, ADDQi, ADDQr, ADDS, ADDT, ANDi, ANDr, BICi, BICr, BISi, ...
    O << ","; 
    printOperand(MI, 0); 
    O << "\n"; 
    return true;
    break;
  case 1:
    // BEQ, BGE, BGT, BLBC, BLBS, BLE, BLT, BNE, FBEQ, FBGE, FBGT, FBLE, FBLT...
    O << "\n"; 
    return true;
    break;
  case 2:
    // LDA, LDAH, LDBU, LDL, LDL_L, LDQ, LDQ_L, LDS, LDT, LDWU, STB, STL, STQ...
    O << ")\n"; 
    return true;
    break;
  case 3:
    // LDAHr
    O << ")\t\t!gprelhigh\n"; 
    return true;
    break;
  case 4:
    // LDAr, LDBUr, LDLr, LDQr, LDSr, LDTr, LDWUr, STBr, STLr, STQr, STSr, ST...
    O << ")\t\t!gprellow\n"; 
    return true;
    break;
  case 5:
    // LDQl
    O << ")\t\t!literal\n"; 
    return true;
    break;
  case 6:
    // STL_C, STQ_C
    O << "("; 
    printOperand(MI, 3); 
    O << ")\n"; 
    return true;
    break;
  }

}
