//===- TableGen'erated file -------------------------------------*- C++ -*-===//
//
// LLVMC Configuration Library
//
// Automatically generated file, do not edit!
//
//===----------------------------------------------------------------------===//

#include "llvm/CompilerDriver/CompilationGraph.h"
#include "llvm/CompilerDriver/Plugin.h"
#include "llvm/CompilerDriver/Tool.h"

#include "llvm/ADT/StringExtras.h"
#include "llvm/Support/CommandLine.h"

#include <cstdlib>
#include <stdexcept>

using namespace llvm;
using namespace llvmc;

extern cl::opt<std::string> OutputFilename;

inline const char* checkCString(const char* s)
{ return s == NULL ? "" : s; }

cl::opt<bool> AutoGeneratedSwitch_pthread("pthread", cl::desc("Enable threads"));
cl::opt<bool> AutoGeneratedSwitch_c("c", cl::desc("Compile and assemble, but do not link"));
cl::opt<bool> AutoGeneratedSwitch_E("E", cl::desc("Stop after the preprocessing stage, do not run the compiler"));
cl::opt<bool> AutoGeneratedSwitch_fsyntax_dash_only("fsyntax-only", cl::desc("Stop after checking the input for syntax errors"));
cl::opt<bool> AutoGeneratedSwitch_opt("opt", cl::desc("Enable opt"));
cl::list<std::string> AutoGeneratedList_I("I", cl::Prefix, cl::desc("Add a directory to include path"));
cl::list<std::string> AutoGeneratedList_L("L", cl::Prefix, cl::desc("Add a directory to link path"));
cl::list<std::string> AutoGeneratedList_l("l", cl::Prefix, cl::desc("Search a library when linking"));
cl::list<std::string> AutoGeneratedList_Wl_comma_("Wl,", cl::Prefix, cl::desc("Pass options to linker"));
cl::opt<bool> AutoGeneratedSwitch_S("S", cl::desc("Stop after compilation, do not assemble"));
cl::opt<bool> AutoGeneratedSwitch_emit_dash_llvm("emit-llvm", cl::desc("Emit LLVM .ll files instead of native object files"));
cl::list<std::string> AutoGeneratedList_Wo_comma_("Wo,", cl::Prefix, cl::desc("Pass options to opt"));
cl::list<std::string> AutoGeneratedList_include("include", cl::desc("Include the named file prior to preprocessing"));
cl::list<std::string> AutoGeneratedList_Wa_comma_("Wa,", cl::Prefix, cl::desc("Pass options to assembler"));
cl::opt<std::string> AutoGeneratedParameter_linker("linker", cl::desc("Choose linker (possible values: gcc, g++)"));
cl::list<std::string> AutoGeneratedSinkOption(cl::Sink);

namespace {

void PopulateLanguageMapLocal(LanguageMap& langMap) {
    langMap["cc"] = "c++";
    langMap["cp"] = "c++";
    langMap["cxx"] = "c++";
    langMap["cpp"] = "c++";
    langMap["CPP"] = "c++";
    langMap["c++"] = "c++";
    langMap["C"] = "c++";
    langMap["c"] = "c";
    langMap["i"] = "c-cpp-output";
    langMap["mi"] = "objective-c-cpp-output";
    langMap["mm"] = "objective-c++";
    langMap["m"] = "objective-c";
    langMap["s"] = "assembler";
    langMap["S"] = "assembler-with-cpp";
    langMap["ll"] = "llvm-assembler";
    langMap["bc"] = "llvm-bitcode";
    langMap["o"] = "object-code";
    langMap["out"] = "executable";
}

class llc : public Tool{
private:
    static const char* InputLanguages_[];

public:
    const char* Name() const {
        return "llc";
    }

    const char** InputLanguages() const {
        return InputLanguages_;
    }

    const char* OutputLanguage() const {
        return "assembler";
    }

    bool IsJoin() const {
        return false;
    }

    Action GenerateAction(const PathVector& inFiles,
        bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        throw std::runtime_error("llc is not a Join tool!");
    }

    Action GenerateAction(const sys::Path& inFile,
        bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        std::string cmd;
        std::vector<std::string> vec;
        bool stop_compilation = !HasChildren;
        const char* output_suffix = "s";
        std::string out_file;

        if (AutoGeneratedSwitch_S) {
            stop_compilation = true;
        }

        out_file = OutFilename(inFile,
            TempDir, stop_compilation, output_suffix).toString();

        vec.push_back("-relocation-model=pic");
        vec.push_back("-f");
        vec.push_back(inFile.toString());
        vec.push_back("-o");
        vec.push_back(out_file);
        cmd = "llc";
        return Action(cmd, vec, stop_compilation, out_file);
    }

};
const char* llc::InputLanguages_[] = {"llvm-bitcode", 0};

class llvm_as : public Tool{
private:
    static const char* InputLanguages_[];

public:
    const char* Name() const {
        return "llvm_as";
    }

    const char** InputLanguages() const {
        return InputLanguages_;
    }

    const char* OutputLanguage() const {
        return "llvm-bitcode";
    }

    bool IsJoin() const {
        return false;
    }

    Action GenerateAction(const PathVector& inFiles,
        bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        throw std::runtime_error("llvm_as is not a Join tool!");
    }

    Action GenerateAction(const sys::Path& inFile,
        bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        std::string cmd;
        std::vector<std::string> vec;
        bool stop_compilation = !HasChildren;
        const char* output_suffix = "bc";
        std::string out_file;


        out_file = OutFilename(inFile,
            TempDir, stop_compilation, output_suffix).toString();

        vec.push_back(inFile.toString());
        vec.push_back("-o");
        vec.push_back(out_file);
        cmd = "llvm-as";
        return Action(cmd, vec, stop_compilation, out_file);
    }

};
const char* llvm_as::InputLanguages_[] = {"llvm-assembler", 0};

class llvm_gcc_assembler : public Tool{
private:
    static const char* InputLanguages_[];

public:
    const char* Name() const {
        return "llvm_gcc_assembler";
    }

    const char** InputLanguages() const {
        return InputLanguages_;
    }

    const char* OutputLanguage() const {
        return "object-code";
    }

    bool IsJoin() const {
        return false;
    }

    Action GenerateAction(const PathVector& inFiles,
        bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        throw std::runtime_error("llvm_gcc_assembler is not a Join tool!");
    }

    Action GenerateAction(const sys::Path& inFile,
        bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        std::string cmd;
        std::vector<std::string> vec;
        bool stop_compilation = !HasChildren;
        const char* output_suffix = "o";
        std::string out_file;

        if (AutoGeneratedSwitch_c) {
            stop_compilation = true;
        }
        if (!AutoGeneratedList_Wa_comma_.empty()) {
            for (cl::list<std::string>::iterator B = AutoGeneratedList_Wa_comma_.begin(),
            E = AutoGeneratedList_Wa_comma_.end(); B != E; ++B)
                llvm::SplitString(*B, vec, ",");
        }

        out_file = OutFilename(inFile,
            TempDir, stop_compilation, output_suffix).toString();

        vec.push_back("-c");
        vec.push_back("-x");
        vec.push_back("assembler");
        vec.push_back(inFile.toString());
        vec.push_back("-o");
        vec.push_back(out_file);
        cmd = "llvm-gcc";
        return Action(cmd, vec, stop_compilation, out_file);
    }

};
const char* llvm_gcc_assembler::InputLanguages_[] = {"assembler", 0};

class llvm_gcc_c : public Tool{
private:
    static const char* InputLanguages_[];

public:
    const char* Name() const {
        return "llvm_gcc_c";
    }

    const char** InputLanguages() const {
        return InputLanguages_;
    }

    const char* OutputLanguage() const {
        return "llvm-bitcode";
    }

    bool IsJoin() const {
        return false;
    }

    Action GenerateAction(const PathVector& inFiles,
        bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        throw std::runtime_error("llvm_gcc_c is not a Join tool!");
    }

    Action GenerateAction(const sys::Path& inFile,
        bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        std::string cmd;
        std::vector<std::string> vec;
        bool stop_compilation = !HasChildren;
        const char* output_suffix = "bc";
        std::string out_file;

        if (AutoGeneratedSwitch_E) {
            stop_compilation = true;
            output_suffix = "i";
        }
        if ((AutoGeneratedSwitch_emit_dash_llvm)
             && (AutoGeneratedSwitch_S)) {
            output_suffix = "ll";
            stop_compilation = true;
        }
        if ((AutoGeneratedSwitch_emit_dash_llvm)
             && (AutoGeneratedSwitch_c)) {
            stop_compilation = true;
        }
        if (AutoGeneratedSwitch_fsyntax_dash_only) {
            stop_compilation = true;
        }
        if (!AutoGeneratedList_include.empty()) {
            for (cl::list<std::string>::iterator B = AutoGeneratedList_include.begin(),
            E = AutoGeneratedList_include.end() ; B != E;) {
                vec.push_back("-include");
                vec.push_back(*B);
                ++B;
            }
        }
        if (!AutoGeneratedList_I.empty()) {
            for (cl::list<std::string>::iterator B = AutoGeneratedList_I.begin(),
            E = AutoGeneratedList_I.end(); B != E;) {
                vec.push_back("-I" + *B);
                ++B;
            }
        }

        out_file = OutFilename(inFile,
            TempDir, stop_compilation, output_suffix).toString();

        if (AutoGeneratedSwitch_E) {
            if (!OutputFilename.empty()) {
                vec.push_back("-x");
                vec.push_back("c");
                vec.push_back("-E");
                vec.push_back(inFile.toString());
                vec.push_back("-o");
                vec.push_back(out_file);
                cmd = "llvm-gcc";
            }
            else {
                vec.push_back("-x");
                vec.push_back("c");
                vec.push_back("-E");
                vec.push_back(inFile.toString());
                cmd = "llvm-gcc";
            }
        }
        else if (AutoGeneratedSwitch_fsyntax_dash_only) {
            vec.push_back("-x");
            vec.push_back("c");
            vec.push_back("-fsyntax-only");
            vec.push_back(inFile.toString());
            cmd = "llvm-gcc";
        }
        else if ((AutoGeneratedSwitch_S)
             && (AutoGeneratedSwitch_emit_dash_llvm)) {
            vec.push_back("-x");
            vec.push_back("c");
            vec.push_back("-S");
            vec.push_back(inFile.toString());
            vec.push_back("-o");
            vec.push_back(out_file);
            vec.push_back("-emit-llvm");
            cmd = "llvm-gcc";
        }
        else {
            vec.push_back("-x");
            vec.push_back("c");
            vec.push_back("-c");
            vec.push_back(inFile.toString());
            vec.push_back("-o");
            vec.push_back(out_file);
            vec.push_back("-emit-llvm");
            cmd = "llvm-gcc";
        }
        if (!AutoGeneratedSinkOption.empty()) {
            vec.insert(vec.end(), AutoGeneratedSinkOption.begin(), AutoGeneratedSinkOption.end());
        }
        return Action(cmd, vec, stop_compilation, out_file);
    }

};
const char* llvm_gcc_c::InputLanguages_[] = {"c", 0};

class llvm_gcc_cpp : public Tool{
private:
    static const char* InputLanguages_[];

public:
    const char* Name() const {
        return "llvm_gcc_cpp";
    }

    const char** InputLanguages() const {
        return InputLanguages_;
    }

    const char* OutputLanguage() const {
        return "llvm-bitcode";
    }

    bool IsJoin() const {
        return false;
    }

    Action GenerateAction(const PathVector& inFiles,
        bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        throw std::runtime_error("llvm_gcc_cpp is not a Join tool!");
    }

    Action GenerateAction(const sys::Path& inFile,
        bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        std::string cmd;
        std::vector<std::string> vec;
        bool stop_compilation = !HasChildren;
        const char* output_suffix = "bc";
        std::string out_file;

        if (AutoGeneratedSwitch_E) {
            stop_compilation = true;
            output_suffix = "i";
        }
        if ((AutoGeneratedSwitch_emit_dash_llvm)
             && (AutoGeneratedSwitch_S)) {
            output_suffix = "ll";
            stop_compilation = true;
        }
        if ((AutoGeneratedSwitch_emit_dash_llvm)
             && (AutoGeneratedSwitch_c)) {
            stop_compilation = true;
        }
        if (AutoGeneratedSwitch_fsyntax_dash_only) {
            stop_compilation = true;
        }
        if (!AutoGeneratedList_include.empty()) {
            for (cl::list<std::string>::iterator B = AutoGeneratedList_include.begin(),
            E = AutoGeneratedList_include.end() ; B != E;) {
                vec.push_back("-include");
                vec.push_back(*B);
                ++B;
            }
        }
        if (!AutoGeneratedList_I.empty()) {
            for (cl::list<std::string>::iterator B = AutoGeneratedList_I.begin(),
            E = AutoGeneratedList_I.end(); B != E;) {
                vec.push_back("-I" + *B);
                ++B;
            }
        }

        out_file = OutFilename(inFile,
            TempDir, stop_compilation, output_suffix).toString();

        if (AutoGeneratedSwitch_E) {
            if (!OutputFilename.empty()) {
                vec.push_back("-x");
                vec.push_back("c++");
                vec.push_back("-E");
                vec.push_back(inFile.toString());
                vec.push_back("-o");
                vec.push_back(out_file);
                cmd = "llvm-g++";
            }
            else {
                vec.push_back("-x");
                vec.push_back("c++");
                vec.push_back("-E");
                vec.push_back(inFile.toString());
                cmd = "llvm-g++";
            }
        }
        else if (AutoGeneratedSwitch_fsyntax_dash_only) {
            vec.push_back("-x");
            vec.push_back("c++");
            vec.push_back("-fsyntax-only");
            vec.push_back(inFile.toString());
            cmd = "llvm-g++";
        }
        else if ((AutoGeneratedSwitch_S)
             && (AutoGeneratedSwitch_emit_dash_llvm)) {
            vec.push_back("-x");
            vec.push_back("c++");
            vec.push_back("-S");
            vec.push_back(inFile.toString());
            vec.push_back("-o");
            vec.push_back(out_file);
            vec.push_back("-emit-llvm");
            cmd = "llvm-g++";
        }
        else {
            vec.push_back("-x");
            vec.push_back("c++");
            vec.push_back("-c");
            vec.push_back(inFile.toString());
            vec.push_back("-o");
            vec.push_back(out_file);
            vec.push_back("-emit-llvm");
            cmd = "llvm-g++";
        }
        if (!AutoGeneratedSinkOption.empty()) {
            vec.insert(vec.end(), AutoGeneratedSinkOption.begin(), AutoGeneratedSinkOption.end());
        }
        return Action(cmd, vec, stop_compilation, out_file);
    }

};
const char* llvm_gcc_cpp::InputLanguages_[] = {"c++", 0};

class llvm_gcc_cpp_linker : public JoinTool{
private:
    static const char* InputLanguages_[];

public:
    const char* Name() const {
        return "llvm_gcc_cpp_linker";
    }

    const char** InputLanguages() const {
        return InputLanguages_;
    }

    const char* OutputLanguage() const {
        return "executable";
    }

    bool IsJoin() const {
        return true;
    }

    Action GenerateAction(const PathVector& inFiles,
        bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        std::string cmd;
        std::vector<std::string> vec;
        bool stop_compilation = !HasChildren;
        const char* output_suffix = "out";
        std::string out_file;

        if (AutoGeneratedSwitch_pthread) {
            vec.push_back("-lpthread");
        }
        if (!AutoGeneratedList_L.empty()) {
            for (cl::list<std::string>::iterator B = AutoGeneratedList_L.begin(),
            E = AutoGeneratedList_L.end(); B != E;) {
                vec.push_back("-L" + *B);
                ++B;
            }
        }
        if (!AutoGeneratedList_l.empty()) {
            for (cl::list<std::string>::iterator B = AutoGeneratedList_l.begin(),
            E = AutoGeneratedList_l.end(); B != E;) {
                vec.push_back("-l" + *B);
                ++B;
            }
        }
        if (!AutoGeneratedList_Wl_comma_.empty()) {
            for (cl::list<std::string>::iterator B = AutoGeneratedList_Wl_comma_.begin(),
            E = AutoGeneratedList_Wl_comma_.end(); B != E; ++B)
                llvm::SplitString(*B, vec, ",");
        }

        out_file = OutFilename(sys::Path(),
            TempDir, stop_compilation, output_suffix).toString();

        for (PathVector::const_iterator B = inFiles.begin(), E = inFiles.end();
        B != E; ++B)
            vec.push_back(B->toString());
        vec.push_back("-o");
        vec.push_back(out_file);
        cmd = "llvm-g++";
        return Action(cmd, vec, stop_compilation, out_file);
    }

    Action GenerateAction(const sys::Path& inFile,
        bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        std::string cmd;
        std::vector<std::string> vec;
        bool stop_compilation = !HasChildren;
        const char* output_suffix = "out";
        std::string out_file;

        if (AutoGeneratedSwitch_pthread) {
            vec.push_back("-lpthread");
        }
        if (!AutoGeneratedList_L.empty()) {
            for (cl::list<std::string>::iterator B = AutoGeneratedList_L.begin(),
            E = AutoGeneratedList_L.end(); B != E;) {
                vec.push_back("-L" + *B);
                ++B;
            }
        }
        if (!AutoGeneratedList_l.empty()) {
            for (cl::list<std::string>::iterator B = AutoGeneratedList_l.begin(),
            E = AutoGeneratedList_l.end(); B != E;) {
                vec.push_back("-l" + *B);
                ++B;
            }
        }
        if (!AutoGeneratedList_Wl_comma_.empty()) {
            for (cl::list<std::string>::iterator B = AutoGeneratedList_Wl_comma_.begin(),
            E = AutoGeneratedList_Wl_comma_.end(); B != E; ++B)
                llvm::SplitString(*B, vec, ",");
        }

        out_file = OutFilename(inFile,
            TempDir, stop_compilation, output_suffix).toString();

        vec.push_back(inFile.toString());
        vec.push_back("-o");
        vec.push_back(out_file);
        cmd = "llvm-g++";
        return Action(cmd, vec, stop_compilation, out_file);
    }

};
const char* llvm_gcc_cpp_linker::InputLanguages_[] = {"object-code", 0};

class llvm_gcc_linker : public JoinTool{
private:
    static const char* InputLanguages_[];

public:
    const char* Name() const {
        return "llvm_gcc_linker";
    }

    const char** InputLanguages() const {
        return InputLanguages_;
    }

    const char* OutputLanguage() const {
        return "executable";
    }

    bool IsJoin() const {
        return true;
    }

    Action GenerateAction(const PathVector& inFiles,
        bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        std::string cmd;
        std::vector<std::string> vec;
        bool stop_compilation = !HasChildren;
        const char* output_suffix = "out";
        std::string out_file;

        if (AutoGeneratedSwitch_pthread) {
            vec.push_back("-lpthread");
        }
        if (!AutoGeneratedList_L.empty()) {
            for (cl::list<std::string>::iterator B = AutoGeneratedList_L.begin(),
            E = AutoGeneratedList_L.end(); B != E;) {
                vec.push_back("-L" + *B);
                ++B;
            }
        }
        if (!AutoGeneratedList_l.empty()) {
            for (cl::list<std::string>::iterator B = AutoGeneratedList_l.begin(),
            E = AutoGeneratedList_l.end(); B != E;) {
                vec.push_back("-l" + *B);
                ++B;
            }
        }
        if (!AutoGeneratedList_Wl_comma_.empty()) {
            for (cl::list<std::string>::iterator B = AutoGeneratedList_Wl_comma_.begin(),
            E = AutoGeneratedList_Wl_comma_.end(); B != E; ++B)
                llvm::SplitString(*B, vec, ",");
        }

        out_file = OutFilename(sys::Path(),
            TempDir, stop_compilation, output_suffix).toString();

        for (PathVector::const_iterator B = inFiles.begin(), E = inFiles.end();
        B != E; ++B)
            vec.push_back(B->toString());
        vec.push_back("-o");
        vec.push_back(out_file);
        cmd = "llvm-gcc";
        return Action(cmd, vec, stop_compilation, out_file);
    }

    Action GenerateAction(const sys::Path& inFile,
        bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        std::string cmd;
        std::vector<std::string> vec;
        bool stop_compilation = !HasChildren;
        const char* output_suffix = "out";
        std::string out_file;

        if (AutoGeneratedSwitch_pthread) {
            vec.push_back("-lpthread");
        }
        if (!AutoGeneratedList_L.empty()) {
            for (cl::list<std::string>::iterator B = AutoGeneratedList_L.begin(),
            E = AutoGeneratedList_L.end(); B != E;) {
                vec.push_back("-L" + *B);
                ++B;
            }
        }
        if (!AutoGeneratedList_l.empty()) {
            for (cl::list<std::string>::iterator B = AutoGeneratedList_l.begin(),
            E = AutoGeneratedList_l.end(); B != E;) {
                vec.push_back("-l" + *B);
                ++B;
            }
        }
        if (!AutoGeneratedList_Wl_comma_.empty()) {
            for (cl::list<std::string>::iterator B = AutoGeneratedList_Wl_comma_.begin(),
            E = AutoGeneratedList_Wl_comma_.end(); B != E; ++B)
                llvm::SplitString(*B, vec, ",");
        }

        out_file = OutFilename(inFile,
            TempDir, stop_compilation, output_suffix).toString();

        vec.push_back(inFile.toString());
        vec.push_back("-o");
        vec.push_back(out_file);
        cmd = "llvm-gcc";
        return Action(cmd, vec, stop_compilation, out_file);
    }

};
const char* llvm_gcc_linker::InputLanguages_[] = {"object-code", 0};

class llvm_gcc_m : public Tool{
private:
    static const char* InputLanguages_[];

public:
    const char* Name() const {
        return "llvm_gcc_m";
    }

    const char** InputLanguages() const {
        return InputLanguages_;
    }

    const char* OutputLanguage() const {
        return "llvm-bitcode";
    }

    bool IsJoin() const {
        return false;
    }

    Action GenerateAction(const PathVector& inFiles,
        bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        throw std::runtime_error("llvm_gcc_m is not a Join tool!");
    }

    Action GenerateAction(const sys::Path& inFile,
        bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        std::string cmd;
        std::vector<std::string> vec;
        bool stop_compilation = !HasChildren;
        const char* output_suffix = "bc";
        std::string out_file;

        if (AutoGeneratedSwitch_E) {
            stop_compilation = true;
            output_suffix = "mi";
        }
        if ((AutoGeneratedSwitch_emit_dash_llvm)
             && (AutoGeneratedSwitch_S)) {
            output_suffix = "ll";
            stop_compilation = true;
        }
        if ((AutoGeneratedSwitch_emit_dash_llvm)
             && (AutoGeneratedSwitch_c)) {
            stop_compilation = true;
        }
        if (AutoGeneratedSwitch_fsyntax_dash_only) {
            stop_compilation = true;
        }
        if (!AutoGeneratedList_include.empty()) {
            for (cl::list<std::string>::iterator B = AutoGeneratedList_include.begin(),
            E = AutoGeneratedList_include.end() ; B != E;) {
                vec.push_back("-include");
                vec.push_back(*B);
                ++B;
            }
        }
        if (!AutoGeneratedList_I.empty()) {
            for (cl::list<std::string>::iterator B = AutoGeneratedList_I.begin(),
            E = AutoGeneratedList_I.end(); B != E;) {
                vec.push_back("-I" + *B);
                ++B;
            }
        }

        out_file = OutFilename(inFile,
            TempDir, stop_compilation, output_suffix).toString();

        if (AutoGeneratedSwitch_E) {
            if (!OutputFilename.empty()) {
                vec.push_back("-x");
                vec.push_back("objective-c");
                vec.push_back("-E");
                vec.push_back(inFile.toString());
                vec.push_back("-o");
                vec.push_back(out_file);
                cmd = "llvm-gcc";
            }
            else {
                vec.push_back("-x");
                vec.push_back("objective-c");
                vec.push_back("-E");
                vec.push_back(inFile.toString());
                cmd = "llvm-gcc";
            }
        }
        else if (AutoGeneratedSwitch_fsyntax_dash_only) {
            vec.push_back("-x");
            vec.push_back("objective-c");
            vec.push_back("-fsyntax-only");
            vec.push_back(inFile.toString());
            cmd = "llvm-gcc";
        }
        else if ((AutoGeneratedSwitch_S)
             && (AutoGeneratedSwitch_emit_dash_llvm)) {
            vec.push_back("-x");
            vec.push_back("objective-c");
            vec.push_back("-S");
            vec.push_back(inFile.toString());
            vec.push_back("-o");
            vec.push_back(out_file);
            vec.push_back("-emit-llvm");
            cmd = "llvm-gcc";
        }
        else {
            vec.push_back("-x");
            vec.push_back("objective-c");
            vec.push_back("-c");
            vec.push_back(inFile.toString());
            vec.push_back("-o");
            vec.push_back(out_file);
            vec.push_back("-emit-llvm");
            cmd = "llvm-gcc";
        }
        if (!AutoGeneratedSinkOption.empty()) {
            vec.insert(vec.end(), AutoGeneratedSinkOption.begin(), AutoGeneratedSinkOption.end());
        }
        return Action(cmd, vec, stop_compilation, out_file);
    }

};
const char* llvm_gcc_m::InputLanguages_[] = {"objective-c", 0};

class llvm_gcc_mxx : public Tool{
private:
    static const char* InputLanguages_[];

public:
    const char* Name() const {
        return "llvm_gcc_mxx";
    }

    const char** InputLanguages() const {
        return InputLanguages_;
    }

    const char* OutputLanguage() const {
        return "llvm-bitcode";
    }

    bool IsJoin() const {
        return false;
    }

    Action GenerateAction(const PathVector& inFiles,
        bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        throw std::runtime_error("llvm_gcc_mxx is not a Join tool!");
    }

    Action GenerateAction(const sys::Path& inFile,
        bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        std::string cmd;
        std::vector<std::string> vec;
        bool stop_compilation = !HasChildren;
        const char* output_suffix = "bc";
        std::string out_file;

        if (AutoGeneratedSwitch_E) {
            stop_compilation = true;
            output_suffix = "mi";
        }
        if ((AutoGeneratedSwitch_emit_dash_llvm)
             && (AutoGeneratedSwitch_S)) {
            output_suffix = "ll";
            stop_compilation = true;
        }
        if ((AutoGeneratedSwitch_emit_dash_llvm)
             && (AutoGeneratedSwitch_c)) {
            stop_compilation = true;
        }
        if (AutoGeneratedSwitch_fsyntax_dash_only) {
            stop_compilation = true;
        }
        if (!AutoGeneratedList_include.empty()) {
            for (cl::list<std::string>::iterator B = AutoGeneratedList_include.begin(),
            E = AutoGeneratedList_include.end() ; B != E;) {
                vec.push_back("-include");
                vec.push_back(*B);
                ++B;
            }
        }
        if (!AutoGeneratedList_I.empty()) {
            for (cl::list<std::string>::iterator B = AutoGeneratedList_I.begin(),
            E = AutoGeneratedList_I.end(); B != E;) {
                vec.push_back("-I" + *B);
                ++B;
            }
        }

        out_file = OutFilename(inFile,
            TempDir, stop_compilation, output_suffix).toString();

        if (AutoGeneratedSwitch_E) {
            if (!OutputFilename.empty()) {
                vec.push_back("-x");
                vec.push_back("objective-c++");
                vec.push_back("-E");
                vec.push_back(inFile.toString());
                vec.push_back("-o");
                vec.push_back(out_file);
                cmd = "llvm-gcc";
            }
            else {
                vec.push_back("-x");
                vec.push_back("objective-c++");
                vec.push_back("-E");
                vec.push_back(inFile.toString());
                cmd = "llvm-gcc";
            }
        }
        else if (AutoGeneratedSwitch_fsyntax_dash_only) {
            vec.push_back("-x");
            vec.push_back("objective-c++");
            vec.push_back("-fsyntax-only");
            vec.push_back(inFile.toString());
            cmd = "llvm-gcc";
        }
        else if ((AutoGeneratedSwitch_S)
             && (AutoGeneratedSwitch_emit_dash_llvm)) {
            vec.push_back("-x");
            vec.push_back("objective-c++");
            vec.push_back("-S");
            vec.push_back(inFile.toString());
            vec.push_back("-o");
            vec.push_back(out_file);
            vec.push_back("-emit-llvm");
            cmd = "llvm-gcc";
        }
        else {
            vec.push_back("-x");
            vec.push_back("objective-c++");
            vec.push_back("-c");
            vec.push_back(inFile.toString());
            vec.push_back("-o");
            vec.push_back(out_file);
            vec.push_back("-emit-llvm");
            cmd = "llvm-gcc";
        }
        if (!AutoGeneratedSinkOption.empty()) {
            vec.insert(vec.end(), AutoGeneratedSinkOption.begin(), AutoGeneratedSinkOption.end());
        }
        return Action(cmd, vec, stop_compilation, out_file);
    }

};
const char* llvm_gcc_mxx::InputLanguages_[] = {"objective-c++", 0};

class opt : public Tool{
private:
    static const char* InputLanguages_[];

public:
    const char* Name() const {
        return "opt";
    }

    const char** InputLanguages() const {
        return InputLanguages_;
    }

    const char* OutputLanguage() const {
        return "llvm-bitcode";
    }

    bool IsJoin() const {
        return false;
    }

    Action GenerateAction(const PathVector& inFiles,
        bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        throw std::runtime_error("opt is not a Join tool!");
    }

    Action GenerateAction(const sys::Path& inFile,
        bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        std::string cmd;
        std::vector<std::string> vec;
        bool stop_compilation = !HasChildren;
        const char* output_suffix = "bc";
        std::string out_file;

        if (!AutoGeneratedList_Wo_comma_.empty()) {
            for (cl::list<std::string>::iterator B = AutoGeneratedList_Wo_comma_.begin(),
            E = AutoGeneratedList_Wo_comma_.end(); B != E; ++B)
                llvm::SplitString(*B, vec, ",");
        }

        out_file = OutFilename(inFile,
            TempDir, stop_compilation, output_suffix).toString();

        vec.push_back("-f");
        vec.push_back(inFile.toString());
        vec.push_back("-o");
        vec.push_back(out_file);
        cmd = "opt";
        return Action(cmd, vec, stop_compilation, out_file);
    }

};
const char* opt::InputLanguages_[] = {"llvm-bitcode", 0};

class Edge11: public Edge {
public:
    Edge11() : Edge("opt") {}

    unsigned Weight(const InputLanguagesSet& InLangs) const {
        unsigned ret = 0;
        if (AutoGeneratedSwitch_opt) {
            ret += 2;
        }
        return ret;
    };

};

class Edge12: public Edge {
public:
    Edge12() : Edge("opt") {}

    unsigned Weight(const InputLanguagesSet& InLangs) const {
        unsigned ret = 0;
        if (AutoGeneratedSwitch_opt) {
            ret += 2;
        }
        return ret;
    };

};

class Edge13: public Edge {
public:
    Edge13() : Edge("opt") {}

    unsigned Weight(const InputLanguagesSet& InLangs) const {
        unsigned ret = 0;
        if (AutoGeneratedSwitch_opt) {
            ret += 2;
        }
        return ret;
    };

};

class Edge14: public Edge {
public:
    Edge14() : Edge("opt") {}

    unsigned Weight(const InputLanguagesSet& InLangs) const {
        unsigned ret = 0;
        if (AutoGeneratedSwitch_opt) {
            ret += 2;
        }
        return ret;
    };

};

class Edge15: public Edge {
public:
    Edge15() : Edge("opt") {}

    unsigned Weight(const InputLanguagesSet& InLangs) const {
        unsigned ret = 0;
        if (AutoGeneratedSwitch_opt) {
            ret += 2;
        }
        return ret;
    };

};

class Edge19: public Edge {
public:
    Edge19() : Edge("llvm_gcc_cpp_linker") {}

    unsigned Weight(const InputLanguagesSet& InLangs) const {
        unsigned ret = 0;
        if ((InLangs.count("c++") != 0)
             || (InLangs.count("objective-c++") != 0)) {
            ret += 2;
        }
        if ((AutoGeneratedParameter_linker == "g++")
             || (AutoGeneratedParameter_linker == "c++")) {
            ret += 2;
        }
        return ret;
    };

};

class Edge21: public Edge {
public:
    Edge21() : Edge("llvm_gcc_cpp_linker") {}

    unsigned Weight(const InputLanguagesSet& InLangs) const {
        unsigned ret = 0;
        if ((InLangs.count("c++") != 0)
             || (InLangs.count("objective-c++") != 0)) {
            ret += 2;
        }
        if ((AutoGeneratedParameter_linker == "g++")
             || (AutoGeneratedParameter_linker == "c++")) {
            ret += 2;
        }
        return ret;
    };

};

void PopulateCompilationGraphLocal(CompilationGraph& G) {
    G.insertNode(new llc());
    G.insertNode(new llvm_as());
    G.insertNode(new llvm_gcc_assembler());
    G.insertNode(new llvm_gcc_c());
    G.insertNode(new llvm_gcc_cpp());
    G.insertNode(new llvm_gcc_cpp_linker());
    G.insertNode(new llvm_gcc_linker());
    G.insertNode(new llvm_gcc_m());
    G.insertNode(new llvm_gcc_mxx());
    G.insertNode(new opt());

    G.insertEdge("root", new SimpleEdge("llvm_gcc_c"));
    G.insertEdge("root", new SimpleEdge("llvm_gcc_assembler"));
    G.insertEdge("root", new SimpleEdge("llvm_gcc_cpp"));
    G.insertEdge("root", new SimpleEdge("llvm_gcc_m"));
    G.insertEdge("root", new SimpleEdge("llvm_gcc_mxx"));
    G.insertEdge("root", new SimpleEdge("llvm_as"));
    G.insertEdge("llvm_gcc_c", new SimpleEdge("llc"));
    G.insertEdge("llvm_gcc_cpp", new SimpleEdge("llc"));
    G.insertEdge("llvm_gcc_m", new SimpleEdge("llc"));
    G.insertEdge("llvm_gcc_mxx", new SimpleEdge("llc"));
    G.insertEdge("llvm_as", new SimpleEdge("llc"));
    G.insertEdge("llvm_gcc_c", new Edge11());
    G.insertEdge("llvm_gcc_cpp", new Edge12());
    G.insertEdge("llvm_gcc_m", new Edge13());
    G.insertEdge("llvm_gcc_mxx", new Edge14());
    G.insertEdge("llvm_as", new Edge15());
    G.insertEdge("opt", new SimpleEdge("llc"));
    G.insertEdge("llc", new SimpleEdge("llvm_gcc_assembler"));
    G.insertEdge("llvm_gcc_assembler", new SimpleEdge("llvm_gcc_linker"));
    G.insertEdge("llvm_gcc_assembler", new Edge19());
    G.insertEdge("root", new SimpleEdge("llvm_gcc_linker"));
    G.insertEdge("root", new Edge21());
}

struct Plugin : public llvmc::BasePlugin {

    int Priority() const { return 0; }

    void PopulateLanguageMap(LanguageMap& langMap) const
    { PopulateLanguageMapLocal(langMap); }

    void PopulateCompilationGraph(CompilationGraph& graph) const
    { PopulateCompilationGraphLocal(graph); }
};

static llvmc::RegisterPlugin<Plugin> RP;

} // End anonymous namespace.
