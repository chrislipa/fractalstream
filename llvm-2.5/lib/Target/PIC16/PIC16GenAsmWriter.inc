//===- TableGen'erated file -------------------------------------*- C++ -*-===//
//
// Assembly Writer Source Fragment
//
// Automatically generated file, do not edit!
//
//===----------------------------------------------------------------------===//

/// printInstruction - This method is automatically generated by tablegen
/// from the instruction set description.  This method returns true if the
/// machine instruction was sufficiently described to print it, otherwise
/// it returns false.
bool PIC16AsmPrinter::printInstruction(const MachineInstr *MI) {
  static const unsigned OpInfo[] = {
    2U,	// PHI
    0U,	// INLINEASM
    0U,	// DBG_LABEL
    0U,	// EH_LABEL
    0U,	// GC_LABEL
    0U,	// DECLARE
    0U,	// EXTRACT_SUBREG
    0U,	// INSERT_SUBREG
    0U,	// IMPLICIT_DEF
    0U,	// SUBREG_TO_REG
    536870923U,	// ADJCALLSTACKDOWN
    536870942U,	// ADJCALLSTACKUP
    1073741871U,	// AndFW
    1677721647U,	// AndWF
    536870966U,	// CALL
    1073741884U,	// OrFW
    1677721660U,	// OrWF
    67U,	// Return
    75U,	// SELECT_CC_Int_ICC
    1073741928U,	// XOrFW
    1677721704U,	// XOrWF
    1073741935U,	// addfw_1
    1073741935U,	// addfw_2
    1073741942U,	// addfwc
    1610612862U,	// addlw_1
    1610612862U,	// addlw_2
    1610612869U,	// addlwc
    1677721711U,	// addwf_1
    1677721711U,	// addwf_2
    1677721718U,	// addwfc
    1610612877U,	// andlw
    2147483796U,	// banksel
    536871069U,	// br_uncond
    671088803U,	// copy_fsr
    671088813U,	// copy_w
    1811939509U,	// load_indirect
    1694499004U,	// movf
    2264924348U,	// movf_1
    2264924348U,	// movf_2
    2147483842U,	// movlw
    2415919305U,	// movlw_hi
    2415919317U,	// movlw_lo
    1677721824U,	// movwf
    2248147168U,	// movwf_1
    2248147168U,	// movwf_2
    1610612967U,	// orlw
    2684354798U,	// pic16brcond
    872415456U,	// set_fsrhi
    939524320U,	// set_fsrlo
    1811939568U,	// store_indirect
    1073742071U,	// subfw_1
    1073742071U,	// subfw_2
    1073742071U,	// subfw_cc
    1073742078U,	// subfwb
    1610612998U,	// sublw_1
    1610612998U,	// sublw_2
    1610612998U,	// sublw_cc
    1677721847U,	// subwf_1
    1677721847U,	// subwf_2
    1677721847U,	// subwf_cc
    1677721854U,	// subwfb
    1610613005U,	// xorlw
    0U
  };

  const char *AsmStrs = 
    "\000\000PHINODE\n\000!ADJCALLSTACKDOWN \000!ADJCALLSTACKUP \000andwf \000"
    "call \000iorwf \000return\n\000; SELECT_CC_Int_ICC PSEUDO!\n\000xorwf \000"
    "addwf \000addwfc \000addlw \000addlwc \000andlw \000banksel \000goto \000"
    "copy_fsr \000copy_w \000moviw \000movf \000movlw \000movlw HIGH(\000mov"
    "lw LOW(\000movwf \000iorlw \000b\000movwi \000subwf \000subwfb \000subl"
    "w \000xorlw \000";

  if (MI->getOpcode() == TargetInstrInfo::INLINEASM) {
    O << "\t";
    printInlineAsm(MI);
    return true;
  } else if (MI->isLabel()) {
    printLabel(MI);
    return true;
  } else if (MI->getOpcode() == TargetInstrInfo::DECLARE) {
    printDeclare(MI);
    return true;
  } else if (MI->getOpcode() == TargetInstrInfo::IMPLICIT_DEF) {
    printImplicitDef(MI);
    return true;
  }

  O << "\t";

  // Emit the opcode for the instruction.
  unsigned Bits = OpInfo[MI->getOpcode()];
  if (Bits == 0) return false;
  O << AsmStrs+(Bits & 511);


  // Fragment 0 encoded into 3 bits for 6 unique commands.
  switch ((Bits >> 29) & 7) {
  default:   // unreachable.
  case 0:
    return true;
    break;
  case 1:
    // ADJCALLSTACKDOWN, ADJCALLSTACKUP, CALL, br_uncond, copy_fsr, copy_w, s...
    printOperand(MI, 0); 
    break;
  case 2:
    // AndFW, OrFW, XOrFW, addfw_1, addfw_2, addfwc, subfw_1, subfw_2, subfw_...
    printOperand(MI, 3); 
    O << " + "; 
    printOperand(MI, 2); 
    O << ", W\n"; 
    return true;
    break;
  case 3:
    // AndWF, OrWF, XOrWF, addlw_1, addlw_2, addlwc, addwf_1, addwf_2, addwfc...
    printOperand(MI, 2); 
    break;
  case 4:
    // banksel, movf_1, movf_2, movlw, movlw_hi, movlw_lo, movwf_1, movwf_2
    printOperand(MI, 1); 
    break;
  case 5:
    // pic16brcond
    printCCOperand(MI, 1); 
    O << " "; 
    printOperand(MI, 0); 
    O << "\n"; 
    return true;
    break;
  }


  // Fragment 1 encoded into 3 bits for 7 unique commands.
  switch ((Bits >> 26) & 7) {
  default:   // unreachable.
  case 0:
    // ADJCALLSTACKDOWN, ADJCALLSTACKUP, CALL, addlw_1, addlw_2, addlwc, andl...
    O << "\n"; 
    return true;
    break;
  case 1:
    // AndWF, OrWF, XOrWF, addwf_1, addwf_2, addwfc, movf, movf_1, movf_2, mo...
    O << " + "; 
    break;
  case 2:
    // copy_fsr, copy_w
    O << ", "; 
    printOperand(MI, 1); 
    O << "\n"; 
    return true;
    break;
  case 3:
    // load_indirect, store_indirect
    O << "["; 
    printOperand(MI, 1); 
    O << "]\n"; 
    return true;
    break;
  case 4:
    // movlw_hi, movlw_lo
    O << ")\n"; 
    return true;
    break;
  case 5:
    // set_fsrhi
    O << "H\n"; 
    return true;
    break;
  case 6:
    // set_fsrlo
    O << "L\n"; 
    return true;
    break;
  }


  // Fragment 2 encoded into 1 bits for 2 unique commands.
  if ((Bits >> 25) & 1) {
    // movf_1, movf_2, movwf_1, movwf_2
    printOperand(MI, 3); 
  } else {
    // AndWF, OrWF, XOrWF, addwf_1, addwf_2, addwfc, movf, movwf, subwf_1, su...
    printOperand(MI, 1); 
  }


  // Fragment 3 encoded into 1 bits for 2 unique commands.
  if ((Bits >> 24) & 1) {
    // movf, movf_1, movf_2
    O << ", W\n"; 
    return true;
  } else {
    // AndWF, OrWF, XOrWF, addwf_1, addwf_2, addwfc, movwf, movwf_1, movwf_2,...
    O << "\n"; 
    return true;
  }

}
