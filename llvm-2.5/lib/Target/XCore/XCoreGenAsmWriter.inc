//===- TableGen'erated file -------------------------------------*- C++ -*-===//
//
// Assembly Writer Source Fragment
//
// Automatically generated file, do not edit!
//
//===----------------------------------------------------------------------===//

/// printInstruction - This method is automatically generated by tablegen
/// from the instruction set description.  This method returns true if the
/// machine instruction was sufficiently described to print it, otherwise
/// it returns false.
bool XCoreAsmPrinter::printInstruction(const MachineInstr *MI) {
  static const unsigned OpInfo[] = {
    2U,	// PHI
    0U,	// INLINEASM
    0U,	// DBG_LABEL
    0U,	// EH_LABEL
    0U,	// GC_LABEL
    0U,	// DECLARE
    0U,	// EXTRACT_SUBREG
    0U,	// INSERT_SUBREG
    0U,	// IMPLICIT_DEF
    0U,	// SUBREG_TO_REG
    1073741835U,	// ADD_2rus
    1073741835U,	// ADD_3r
    2214592513U,	// ADJCALLSTACKDOWN
    2281701377U,	// ADJCALLSTACKUP
    1107296272U,	// ANDNOT_2r
    1073741848U,	// AND_3r
    1073741853U,	// ASHR_l2rus
    1073741853U,	// ASHR_l3r
    1275068451U,	// BAU_1r
    1082130472U,	// BITREV_l2r
    1275068464U,	// BLA_1r
    1275068469U,	// BL_lu10
    1275068469U,	// BL_u10
    1082130489U,	// BRBF_lru6
    1082130489U,	// BRBF_ru6
    1082130493U,	// BRBT_lru6
    1082130493U,	// BRBT_ru6
    1275068481U,	// BRBU_lu6
    1275068481U,	// BRBU_u6
    1082130489U,	// BRFF_lru6
    1082130489U,	// BRFF_ru6
    1082130493U,	// BRFT_lru6
    1082130493U,	// BRFT_ru6
    1275068481U,	// BRFU_lu6
    1275068481U,	// BRFU_u6
    1082130501U,	// BYTEREV_l2r
    1082130510U,	// CLZ_l2r
    1073741907U,	// DIVS_l3r
    1073741913U,	// DIVU_l3r
    1275068511U,	// ECALLF_1r
    1275068519U,	// ECALLT_1r
    1275068527U,	// ENTSP_lu6
    1275068527U,	// ENTSP_u6
    1073741942U,	// EQ_2rus
    1073741942U,	// EQ_3r
    1275068538U,	// EXTSP_lu6
    1275068538U,	// EXTSP_u6
    129U,	// GETID_0R
    1075839118U,	// LADD_l5r
    1090519188U,	// LD16S_3r
    1090519195U,	// LD8U_3r
    1098907809U,	// LDA16B_l3r
    1090519201U,	// LDA16F_l3r
    1275068584U,	// LDAP_lu10
    1275068584U,	// LDAP_u10
    1098907827U,	// LDAWB_l2rus
    1098907827U,	// LDAWB_l3r
    3221225657U,	// LDAWCP_lu6
    3221225657U,	// LDAWCP_u6
    1342177459U,	// LDAWDP_lru6
    1342177459U,	// LDAWDP_ru6
    2483027969U,	// LDAWFI
    1090519219U,	// LDAWF_l2rus
    1090519219U,	// LDAWF_l3r
    1476395187U,	// LDAWSP_lru6
    1476395187U,	// LDAWSP_lru6_RRegs
    1476395187U,	// LDAWSP_ru6
    1476395187U,	// LDAWSP_ru6_RRegs
    1082130631U,	// LDC_lru6
    1082130631U,	// LDC_ru6
    1075839180U,	// LDIV_l5r
    1543504082U,	// LDWCP_lru6
    1543504082U,	// LDWCP_ru6
    1342177490U,	// LDWDP_lru6
    1342177490U,	// LDWDP_ru6
    2684354561U,	// LDWFI
    1476395218U,	// LDWSP_lru6
    1476395218U,	// LDWSP_ru6
    1090519250U,	// LDW_2rus
    1090519250U,	// LDW_3r
    1076887767U,	// LMUL_l6r
    1073742045U,	// LSS_3r
    1075839202U,	// LSUB_l5r
    1073742056U,	// LSU_3r
    1077936365U,	// MACCS_l4r
    1077936372U,	// MACCU_l4r
    1076887803U,	// MACC_l6r
    1082130689U,	// MKMSK_2r
    1082130689U,	// MKMSK_rus
    1073742088U,	// MUL_l3r
    1082130701U,	// NEG
    1082130706U,	// NOT
    1073742103U,	// OR_3r
    1073742107U,	// REMS_l3r
    1073742113U,	// REMU_l3r
    1275068711U,	// RETSP_lu6
    1275068711U,	// RETSP_u6
    2751463425U,	// SELECT_CC
    1275068718U,	// SETSP_1r
    1107296567U,	// SEXT_rus
    1073742141U,	// SHL_2rus
    1073742141U,	// SHL_3r
    1073742146U,	// SHR_2rus
    1073742146U,	// SHR_3r
    1090519367U,	// ST16_l3r
    1090519373U,	// ST8_l3r
    1342177618U,	// STWDP_lru6
    1342177618U,	// STWDP_ru6
    2818572289U,	// STWFI
    1476395346U,	// STWSP_lru6
    1476395346U,	// STWSP_ru6
    1090519378U,	// STW_2rus
    1090519378U,	// STW_3r
    1073742167U,	// SUB_2rus
    1073742167U,	// SUB_3r
    1073742172U,	// XOR_l3r
    1107296609U,	// ZEXT_rus
    0U
  };

  const char *AsmStrs = 
    "\000\000PHINODE\n\000add \000andnot \000and \000ashr \000bau \000bitrev"
    " \000bla \000bl \000bf \000bt \000bu \000byterev \000clz \000divs \000d"
    "ivu \000ecallf \000ecallt \000entsp \000eq \000extsp \000get r11, id\n\000"
    "ladd \000ld16s \000ld8u \000lda16 \000ldap r11, \000ldaw \000ldaw r11, "
    "cp[\000ldc \000ldiv \000ldw \000lmul \000lss \000lsub \000lsu \000maccs"
    " \000maccu \000macc \000mkmsk \000mul \000neg \000not \000or \000rems \000"
    "remu \000retsp \000set sp, \000sext \000shl \000shr \000st16 \000st8 \000"
    "stw \000sub \000xor \000zext \000";

  if (MI->getOpcode() == TargetInstrInfo::INLINEASM) {
    O << "\t";
    printInlineAsm(MI);
    return true;
  } else if (MI->isLabel()) {
    printLabel(MI);
    return true;
  } else if (MI->getOpcode() == TargetInstrInfo::DECLARE) {
    printDeclare(MI);
    return true;
  } else if (MI->getOpcode() == TargetInstrInfo::IMPLICIT_DEF) {
    printImplicitDef(MI);
    return true;
  }

  O << "\t";

  // Emit the opcode for the instruction.
  unsigned Bits = OpInfo[MI->getOpcode()];
  if (Bits == 0) return false;
  O << AsmStrs+(Bits & 511);


  // Fragment 0 encoded into 2 bits for 4 unique commands.
  switch ((Bits >> 30) & 3) {
  default:   // unreachable.
  case 0:
    return true;
    break;
  case 1:
    // ADD_2rus, ADD_3r, ANDNOT_2r, AND_3r, ASHR_l2rus, ASHR_l3r, BAU_1r, BIT...
    printOperand(MI, 0); 
    break;
  case 2:
    // ADJCALLSTACKDOWN, ADJCALLSTACKUP, LDAWFI, LDWFI, SELECT_CC, STWFI
    PrintSpecial(MI, "comment"); 
    break;
  case 3:
    // LDAWCP_lu6, LDAWCP_u6
    printMemOperand(MI, 0); 
    O << "]\n"; 
    return true;
    break;
  }


  // Fragment 1 encoded into 4 bits for 11 unique commands.
  switch ((Bits >> 26) & 15) {
  default:   // unreachable.
  case 0:
    // ADD_2rus, ADD_3r, ANDNOT_2r, AND_3r, ASHR_l2rus, ASHR_l3r, BITREV_l2r,...
    O << ", "; 
    break;
  case 1:
    // ADJCALLSTACKDOWN
    O << " ADJCALLSTACKDOWN "; 
    printOperand(MI, 0); 
    O << "\n"; 
    return true;
    break;
  case 2:
    // ADJCALLSTACKUP
    O << " ADJCALLSTACKUP "; 
    printOperand(MI, 0); 
    O << "\n"; 
    return true;
    break;
  case 3:
    // BAU_1r, BLA_1r, BL_lu10, BL_u10, BRBU_lu6, BRBU_u6, BRFU_lu6, BRFU_u6,...
    O << "\n"; 
    return true;
    break;
  case 4:
    // LDAWDP_lru6, LDAWDP_ru6, LDWDP_lru6, LDWDP_ru6, STWDP_lru6, STWDP_ru6
    O << ", dp["; 
    printMemOperand(MI, 1); 
    O << "]\n"; 
    return true;
    break;
  case 5:
    // LDAWFI
    O << " LDAWFI "; 
    printOperand(MI, 0); 
    O << ", "; 
    printMemOperand(MI, 1); 
    O << "\n"; 
    return true;
    break;
  case 6:
    // LDAWSP_lru6, LDAWSP_lru6_RRegs, LDAWSP_ru6, LDAWSP_ru6_RRegs, LDWSP_lr...
    O << ", sp["; 
    printOperand(MI, 1); 
    O << "]\n"; 
    return true;
    break;
  case 7:
    // LDWCP_lru6, LDWCP_ru6
    O << ", cp["; 
    printOperand(MI, 1); 
    O << "]\n"; 
    return true;
    break;
  case 8:
    // LDWFI
    O << " LDWFI "; 
    printOperand(MI, 0); 
    O << ", "; 
    printMemOperand(MI, 1); 
    O << "\n"; 
    return true;
    break;
  case 9:
    // SELECT_CC
    O << " SELECT_CC PSEUDO!\n"; 
    return true;
    break;
  case 10:
    // STWFI
    O << " STWFI "; 
    printOperand(MI, 0); 
    O << ", "; 
    printMemOperand(MI, 1); 
    O << "\n"; 
    return true;
    break;
  }


  // Fragment 2 encoded into 1 bits for 2 unique commands.
  if ((Bits >> 25) & 1) {
    // ANDNOT_2r, SEXT_rus, ZEXT_rus
    printOperand(MI, 2); 
    O << "\n"; 
    return true;
  } else {
    // ADD_2rus, ADD_3r, AND_3r, ASHR_l2rus, ASHR_l3r, BITREV_l2r, BRBF_lru6,...
    printOperand(MI, 1); 
  }


  // Fragment 3 encoded into 2 bits for 4 unique commands.
  switch ((Bits >> 23) & 3) {
  default:   // unreachable.
  case 0:
    // ADD_2rus, ADD_3r, AND_3r, ASHR_l2rus, ASHR_l3r, DIVS_l3r, DIVU_l3r, EQ...
    O << ", "; 
    break;
  case 1:
    // BITREV_l2r, BRBF_lru6, BRBF_ru6, BRBT_lru6, BRBT_ru6, BRFF_lru6, BRFF_...
    O << "\n"; 
    return true;
    break;
  case 2:
    // LD16S_3r, LD8U_3r, LDA16F_l3r, LDAWF_l2rus, LDAWF_l3r, LDW_2rus, LDW_3...
    O << "["; 
    printOperand(MI, 2); 
    O << "]\n"; 
    return true;
    break;
  case 3:
    // LDA16B_l3r, LDAWB_l2rus, LDAWB_l3r
    O << "[-"; 
    printOperand(MI, 2); 
    O << "]\n"; 
    return true;
    break;
  }


  // Fragment 4 encoded into 1 bits for 2 unique commands.
  if ((Bits >> 22) & 1) {
    // MACCS_l4r, MACCU_l4r
    printOperand(MI, 4); 
    O << ", "; 
    printOperand(MI, 5); 
    O << "\n"; 
    return true;
  } else {
    // ADD_2rus, ADD_3r, AND_3r, ASHR_l2rus, ASHR_l3r, DIVS_l3r, DIVU_l3r, EQ...
    printOperand(MI, 2); 
  }


  // Fragment 5 encoded into 1 bits for 2 unique commands.
  if ((Bits >> 21) & 1) {
    // LADD_l5r, LDIV_l5r, LMUL_l6r, LSUB_l5r, MACC_l6r
    O << ", "; 
    printOperand(MI, 3); 
    O << ", "; 
    printOperand(MI, 4); 
  } else {
    // ADD_2rus, ADD_3r, AND_3r, ASHR_l2rus, ASHR_l3r, DIVS_l3r, DIVU_l3r, EQ...
    O << "\n"; 
    return true;
  }


  // Fragment 6 encoded into 1 bits for 2 unique commands.
  if ((Bits >> 20) & 1) {
    // LMUL_l6r, MACC_l6r
    O << ", "; 
    printOperand(MI, 5); 
    O << "\n"; 
    return true;
  } else {
    // LADD_l5r, LDIV_l5r, LSUB_l5r
    O << "\n"; 
    return true;
  }

}
