//===- TableGen'erated file -------------------------------------*- C++ -*-===//
//
// Assembly Writer Source Fragment
//
// Automatically generated file, do not edit!
//
//===----------------------------------------------------------------------===//

/// printInstruction - This method is automatically generated by tablegen
/// from the instruction set description.  This method returns true if the
/// machine instruction was sufficiently described to print it, otherwise
/// it returns false.
bool SparcAsmPrinter::printInstruction(const MachineInstr *MI) {
  static const unsigned OpInfo[] = {
    2U,	// PHI
    0U,	// INLINEASM
    0U,	// DBG_LABEL
    0U,	// EH_LABEL
    0U,	// GC_LABEL
    0U,	// DECLARE
    0U,	// EXTRACT_SUBREG
    0U,	// INSERT_SUBREG
    0U,	// IMPLICIT_DEF
    0U,	// SUBREG_TO_REG
    268435467U,	// ADDCCri
    268435467U,	// ADDCCrr
    268435474U,	// ADDXri
    268435474U,	// ADDXrr
    268435480U,	// ADDri
    268435480U,	// ADDrr
    570425373U,	// ADJCALLSTACKDOWN
    570425392U,	// ADJCALLSTACKUP
    268435521U,	// ANDNri
    268435521U,	// ANDNrr
    268435527U,	// ANDri
    268435527U,	// ANDrr
    570425420U,	// BA
    805306448U,	// BCOND
    570425426U,	// CALL
    335544408U,	// FABSD
    335544415U,	// FABSS
    268435558U,	// FADDD
    268435565U,	// FADDS
    805306484U,	// FBCOND
    637534327U,	// FCMPD
    637534334U,	// FCMPS
    268435589U,	// FDIVD
    268435596U,	// FDIVS
    335544467U,	// FDTOI
    335544474U,	// FDTOS
    335544481U,	// FITOD
    335544488U,	// FITOS
    335544495U,	// FMOVD
    1207959734U,	// FMOVD_FCC
    1241514166U,	// FMOVD_ICC
    335544508U,	// FMOVS
    1207959747U,	// FMOVS_FCC
    1241514179U,	// FMOVS_ICC
    268435657U,	// FMULD
    268435664U,	// FMULS
    335544535U,	// FNEGD
    335544542U,	// FNEGS
    268435685U,	// FSMULD
    335544557U,	// FSQRTD
    335544565U,	// FSQRTS
    335544573U,	// FSTOD
    335544580U,	// FSTOI
    268435723U,	// FSUBD
    268435730U,	// FSUBS
    335544601U,	// FpABSD
    335544610U,	// FpMOVD
    335544619U,	// FpNEGD
    1342177362U,	// JMPLri
    1342177362U,	// JMPLrr
    1610613044U,	// LDDFri
    1610613044U,	// LDDFrr
    1610613050U,	// LDFri
    1610613050U,	// LDFrr
    1610613055U,	// LDSBri
    1610613055U,	// LDSBrr
    1610613062U,	// LDSHri
    1610613062U,	// LDSHrr
    1610613069U,	// LDUBri
    1610613069U,	// LDUBrr
    1610613076U,	// LDUHri
    1610613076U,	// LDUHrr
    1610613050U,	// LDri
    1610613050U,	// LDrr
    1879048216U,	// LEA_ADDri
    1207959899U,	// MOVFCCri
    1207959899U,	// MOVFCCrr
    1241514331U,	// MOVICCri
    1241514331U,	// MOVICCrr
    351U,	// NOP
    268435812U,	// ORNri
    268435812U,	// ORNrr
    268435817U,	// ORri
    268435817U,	// ORrr
    335544685U,	// POPCrr
    570425715U,	// RDY
    268435835U,	// RESTOREri
    268435835U,	// RESTORErr
    388U,	// RETL
    268435850U,	// SAVEri
    268435850U,	// SAVErr
    268435856U,	// SDIVri
    268435856U,	// SDIVrr
    406U,	// SELECT_CC_DFP_FCC
    435U,	// SELECT_CC_DFP_ICC
    464U,	// SELECT_CC_FP_FCC
    492U,	// SELECT_CC_FP_ICC
    520U,	// SELECT_CC_Int_FCC
    549U,	// SELECT_CC_Int_ICC
    335544898U,	// SETHIi
    268436041U,	// SLLri
    268436041U,	// SLLrr
    268436046U,	// SMULri
    268436046U,	// SMULrr
    268436052U,	// SRAri
    268436052U,	// SRArr
    268436057U,	// SRLri
    268436057U,	// SRLrr
    2147484254U,	// STBri
    2147484254U,	// STBrr
    2147484259U,	// STDFri
    2147484264U,	// STDFrr
    2147484270U,	// STFri
    2147484270U,	// STFrr
    2147484274U,	// STHri
    2147484274U,	// STHrr
    2147484270U,	// STri
    2147484270U,	// STrr
    268436087U,	// SUBCCri
    268436087U,	// SUBCCrr
    268436094U,	// SUBXCCrr
    268436102U,	// SUBXri
    268436102U,	// SUBXrr
    268436108U,	// SUBri
    268436108U,	// SUBrr
    268436113U,	// UDIVri
    268436113U,	// UDIVrr
    268436119U,	// UMULri
    268436119U,	// UMULrr
    654312093U,	// WRYri
    654312093U,	// WRYrr
    268436129U,	// XNORri
    268436129U,	// XNORrr
    268436135U,	// XORri
    268436135U,	// XORrr
    0U
  };

  const char *AsmStrs = 
    "\000\000PHINODE\n\000addcc \000addx \000add \000!ADJCALLSTACKDOWN \000!"
    "ADJCALLSTACKUP \000andn \000and \000ba \000b\000call \000fabsd \000fabs"
    "s \000faddd \000fadds \000fb\000fcmpd \000fcmps \000fdivd \000fdivs \000"
    "fdtoi \000fdtos \000fitod \000fitos \000fmovd \000fmovd\000fmovs \000fm"
    "ovs\000fmuld \000fmuls \000fnegd \000fnegs \000fsmuld \000fsqrtd \000fs"
    "qrts \000fstod \000fstoi \000fsubd \000fsubs \000!FpABSD \000!FpMOVD \000"
    "!FpNEGD \000ldd [\000ld [\000ldsb [\000ldsh [\000ldub [\000lduh [\000mo"
    "v\000nop\n\000orn \000or \000popc \000rd %y, \000restore \000retl\n\000"
    "save \000sdiv \000; SELECT_CC_DFP_FCC PSEUDO!\n\000; SELECT_CC_DFP_ICC "
    "PSEUDO!\n\000; SELECT_CC_FP_FCC PSEUDO!\n\000; SELECT_CC_FP_ICC PSEUDO!"
    "\n\000; SELECT_CC_Int_FCC PSEUDO!\n\000; SELECT_CC_Int_ICC PSEUDO!\n\000"
    "sethi \000sll \000smul \000sra \000srl \000stb \000std \000std  \000st "
    "\000sth \000subcc \000subxcc \000subx \000sub \000udiv \000umul \000wr "
    "\000xnor \000xor \000";

  if (MI->getOpcode() == TargetInstrInfo::INLINEASM) {
    O << "\t";
    printInlineAsm(MI);
    return true;
  } else if (MI->isLabel()) {
    printLabel(MI);
    return true;
  } else if (MI->getOpcode() == TargetInstrInfo::DECLARE) {
    printDeclare(MI);
    return true;
  } else if (MI->getOpcode() == TargetInstrInfo::IMPLICIT_DEF) {
    printImplicitDef(MI);
    return true;
  }

  O << "\t";

  // Emit the opcode for the instruction.
  unsigned Bits = OpInfo[MI->getOpcode()];
  if (Bits == 0) return false;
  O << AsmStrs+(Bits & 1023);


  // Fragment 0 encoded into 4 bits for 9 unique commands.
  switch ((Bits >> 28) & 15) {
  default:   // unreachable.
  case 0:
    return true;
    break;
  case 1:
    // ADDCCri, ADDCCrr, ADDXri, ADDXrr, ADDri, ADDrr, ANDNri, ANDNrr, ANDri,...
    printOperand(MI, 1); 
    O << ", "; 
    break;
  case 2:
    // ADJCALLSTACKDOWN, ADJCALLSTACKUP, BA, CALL, FCMPD, FCMPS, RDY, WRYri, ...
    printOperand(MI, 0); 
    break;
  case 3:
    // BCOND, FBCOND
    printCCOperand(MI, 1); 
    O << " "; 
    printOperand(MI, 0); 
    O << "\n"; 
    return true;
    break;
  case 4:
    // FMOVD_FCC, FMOVD_ICC, FMOVS_FCC, FMOVS_ICC, MOVFCCri, MOVFCCrr, MOVICC...
    printCCOperand(MI, 3); 
    break;
  case 5:
    // JMPLri, JMPLrr
    printMemOperand(MI, 0); 
    O << "\n"; 
    return true;
    break;
  case 6:
    // LDDFri, LDDFrr, LDFri, LDFrr, LDSBri, LDSBrr, LDSHri, LDSHrr, LDUBri, ...
    printMemOperand(MI, 1); 
    O << "], "; 
    printOperand(MI, 0); 
    O << "\n"; 
    return true;
    break;
  case 7:
    // LEA_ADDri
    printMemOperand(MI, 1, "arith"); 
    O << ", "; 
    printOperand(MI, 0); 
    O << "\n"; 
    return true;
    break;
  case 8:
    // STBri, STBrr, STDFri, STDFrr, STFri, STFrr, STHri, STHrr, STri, STrr
    printOperand(MI, 2); 
    O << ", ["; 
    printMemOperand(MI, 0); 
    O << "]\n"; 
    return true;
    break;
  }


  // Fragment 1 encoded into 3 bits for 6 unique commands.
  switch ((Bits >> 25) & 7) {
  default:   // unreachable.
  case 0:
    // ADDCCri, ADDCCrr, ADDXri, ADDXrr, ADDri, ADDrr, ANDNri, ANDNrr, ANDri,...
    printOperand(MI, 2); 
    O << ", "; 
    printOperand(MI, 0); 
    O << "\n"; 
    return true;
    break;
  case 1:
    // ADJCALLSTACKDOWN, ADJCALLSTACKUP, BA, CALL, RDY
    O << "\n"; 
    return true;
    break;
  case 2:
    // FABSD, FABSS, FDTOI, FDTOS, FITOD, FITOS, FMOVD, FMOVS, FNEGD, FNEGS, ...
    printOperand(MI, 0); 
    O << "\n"; 
    return true;
    break;
  case 3:
    // FCMPD, FCMPS, WRYri, WRYrr
    O << ", "; 
    printOperand(MI, 1); 
    break;
  case 4:
    // FMOVD_FCC, FMOVS_FCC, MOVFCCri, MOVFCCrr
    O << " %fcc0, "; 
    printOperand(MI, 2); 
    O << ", "; 
    printOperand(MI, 0); 
    O << "\n"; 
    return true;
    break;
  case 5:
    // FMOVD_ICC, FMOVS_ICC, MOVICCri, MOVICCrr
    O << " %icc, "; 
    printOperand(MI, 2); 
    O << ", "; 
    printOperand(MI, 0); 
    O << "\n"; 
    return true;
    break;
  }


  // Fragment 2 encoded into 1 bits for 2 unique commands.
  if ((Bits >> 24) & 1) {
    // WRYri, WRYrr
    O << ", %y\n"; 
    return true;
  } else {
    // FCMPD, FCMPS
    O << "\n\tnop\n"; 
    return true;
  }

}
