//===- TableGen'erated file -------------------------------------*- C++ -*-===//
//
// Assembly Writer Source Fragment
//
// Automatically generated file, do not edit!
//
//===----------------------------------------------------------------------===//

/// printInstruction - This method is automatically generated by tablegen
/// from the instruction set description.  This method returns true if the
/// machine instruction was sufficiently described to print it, otherwise
/// it returns false.
bool ARMAsmPrinter::printInstruction(const MachineInstr *MI) {
  static const unsigned OpInfo[] = {
    2U,	// PHI
    0U,	// INLINEASM
    0U,	// DBG_LABEL
    0U,	// EH_LABEL
    0U,	// GC_LABEL
    0U,	// DECLARE
    0U,	// EXTRACT_SUBREG
    0U,	// INSERT_SUBREG
    0U,	// IMPLICIT_DEF
    0U,	// SUBREG_TO_REG
    134217739U,	// ADCri
    138412043U,	// ADCrr
    268435467U,	// ADCrs
    411041807U,	// ADDSri
    411049999U,	// ADDSrr
    545275919U,	// ADDSrs
    415367183U,	// ADDri
    415522831U,	// ADDrr
    553648143U,	// ADDrs
    692060179U,	// ADJCALLSTACKDOWN
    692060199U,	// ADJCALLSTACKUP
    415367225U,	// ANDri
    415522873U,	// ANDrr
    553648185U,	// ANDrs
    692060221U,	// B
    415367232U,	// BICri
    415522880U,	// BICrr
    553648192U,	// BICrs
    805306436U,	// BL
    692060232U,	// BLX
    964689997U,	// BL_pred
    700874832U,	// BR_JTadd
    1073741913U,	// BR_JTm
    704643170U,	// BR_JTr
    692060267U,	// BX
    1245708411U,	// BX_RET
    981467262U,	// Bcc
    1388880000U,	// CLZ
    1388880004U,	// CMNnzri
    1388880004U,	// CMNnzrr
    1523097732U,	// CMNnzrs
    1388880004U,	// CMNri
    1388880004U,	// CMNrr
    1523097732U,	// CMNrs
    1388880008U,	// CMPnzri
    1388880008U,	// CMPnzrr
    1523097736U,	// CMPnzrs
    1388880008U,	// CMPri
    1388880008U,	// CMPrr
    1523097736U,	// CMPrs
    1610612737U,	// CONSTPOOL_ENTRY
    1744830604U,	// DWARF_LOC
    415367314U,	// EORri
    415522962U,	// EORrr
    553648274U,	// EORrs
    1388880022U,	// FABSD
    1388880028U,	// FABSS
    449355938U,	// FADDD
    449355944U,	// FADDS
    1388880046U,	// FCMPED
    1388880053U,	// FCMPES
    981467324U,	// FCMPEZD
    981467332U,	// FCMPEZS
    1388880076U,	// FCPYD
    449355980U,	// FCPYDcc
    1388880082U,	// FCPYS
    449355986U,	// FCPYScc
    1388880088U,	// FCVTDS
    1388880095U,	// FCVTSD
    449356006U,	// FDIVD
    449356012U,	// FDIVS
    449356018U,	// FLDD
    1929380087U,	// FLDMD
    1933574391U,	// FLDMS
    449356028U,	// FLDS
    1523097857U,	// FMACD
    1523097863U,	// FMACS
    449356045U,	// FMDRR
    449356051U,	// FMRRD
    1388880153U,	// FMRS
    1523097886U,	// FMSCD
    1523097892U,	// FMSCS
    1388880170U,	// FMSR
    1228931375U,	// FMSTAT
    449356086U,	// FMULD
    449356092U,	// FMULS
    1388880194U,	// FNEGD
    449356098U,	// FNEGDcc
    1388880200U,	// FNEGS
    449356104U,	// FNEGScc
    1523097934U,	// FNMACD
    1523097941U,	// FNMACS
    1523097948U,	// FNMSCD
    1523097955U,	// FNMSCS
    449356138U,	// FNMULD
    449356145U,	// FNMULS
    1388880248U,	// FSITOD
    1388880255U,	// FSITOS
    1388880262U,	// FSQRTD
    1388880269U,	// FSQRTS
    449356180U,	// FSTD
    1929380249U,	// FSTMD
    1933574553U,	// FSTMS
    449356190U,	// FSTS
    449356195U,	// FSUBD
    449356201U,	// FSUBS
    1388880303U,	// FTOSIZD
    1388880311U,	// FTOSIZS
    1388880319U,	// FTOUIZD
    1388880327U,	// FTOUIZS
    1388880335U,	// FUITOD
    1388880342U,	// FUITOS
    1400898013U,	// LDM
    1400898013U,	// LDM_RET
    1523098081U,	// LDR
    1539875297U,	// LDRB
    600359393U,	// LDRB_POST
    600351201U,	// LDRB_PRE
    1543504353U,	// LDRD
    1548263905U,	// LDRH
    608748001U,	// LDRH_POST
    608739809U,	// LDRH_PRE
    1551950305U,	// LDRSB
    613024225U,	// LDRSB_POST
    612434401U,	// LDRSB_PRE
    1556144609U,	// LDRSH
    617218529U,	// LDRSH_POST
    616628705U,	// LDRSH_PRE
    583582177U,	// LDR_POST
    583573985U,	// LDR_PRE
    1523098081U,	// LDRcp
    2098012645U,	// LEApcrel
    2102215141U,	// LEApcrelJT
    1569104369U,	// MLA
    449356277U,	// MOVCCi
    449356277U,	// MOVCCr
    583574005U,	// MOVCCs
    1439564277U,	// MOVi
    1388880373U,	// MOVi2pieces
    1439064565U,	// MOVr
    1439130101U,	// MOVrx
    1569718773U,	// MOVs
    1351746037U,	// MOVsra_flag
    1351877109U,	// MOVsrl_flag
    415523321U,	// MUL
    1439564285U,	// MVNi
    1439064573U,	// MVNr
    1569718781U,	// MVNs
    415367681U,	// ORRri
    415523329U,	// ORRrr
    553648641U,	// ORRrs
    2248146945U,	// PICADD
    2388000769U,	// PICLDR
    2388131841U,	// PICLDRB
    2388262913U,	// PICLDRH
    2388393985U,	// PICLDRSB
    2388525057U,	// PICLDRSH
    2392195073U,	// PICSTR
    2392326145U,	// PICSTRB
    2392457217U,	// PICSTRH
    1523098117U,	// PKHBT
    1523098123U,	// PKHTB
    1388880401U,	// REV
    1388880405U,	// REV16
    1388880411U,	// REVSH
    411042337U,	// RSBSri
    545276449U,	// RSBSrs
    415367713U,	// RSBri
    553648673U,	// RSBrs
    134218277U,	// RSCri
    268436005U,	// RSCrs
    134218281U,	// SBCri
    138412585U,	// SBCrr
    268436009U,	// SBCrs
    1523098157U,	// SMLABB
    1523098164U,	// SMLABT
    1569104443U,	// SMLAL
    1523098177U,	// SMLATB
    1523098184U,	// SMLATT
    1523098191U,	// SMLAWB
    1523098198U,	// SMLAWT
    1523098205U,	// SMMLA
    1523098211U,	// SMMLS
    449356393U,	// SMMUL
    449356399U,	// SMULBB
    449356406U,	// SMULBT
    1569104509U,	// SMULL
    449356419U,	// SMULTB
    449356426U,	// SMULTT
    449356433U,	// SMULWB
    449356440U,	// SMULWT
    1400898207U,	// STM
    1523098275U,	// STR
    1539875491U,	// STRB
    600228515U,	// STRB_POST
    600228515U,	// STRB_PRE
    1543504547U,	// STRD
    1548264099U,	// STRH
    608617123U,	// STRH_POST
    608617123U,	// STRH_PRE
    583451299U,	// STR_POST
    583451299U,	// STR_PRE
    411042471U,	// SUBSri
    411050663U,	// SUBSrr
    545276583U,	// SUBSrs
    415367847U,	// SUBri
    415523495U,	// SUBrr
    553648807U,	// SUBrs
    449356459U,	// SXTABrr
    1523098283U,	// SXTABrr_rot
    449356465U,	// SXTAHrr
    1523098289U,	// SXTAHrr_rot
    1388880567U,	// SXTBr
    449356471U,	// SXTBr_rot
    1388880572U,	// SXTHr
    449356476U,	// SXTHr_rot
    1388880577U,	// TEQri
    1388880577U,	// TEQrr
    1523098305U,	// TEQrs
    709U,	// TPsoft
    1388880601U,	// TSTri
    1388880601U,	// TSTrr
    1523098329U,	// TSTrs
    1523098333U,	// UMAAL
    1569104611U,	// UMLAL
    1569104617U,	// UMULL
    449356527U,	// UXTABrr
    1523098351U,	// UXTABrr_rot
    449356533U,	// UXTAHrr
    1523098357U,	// UXTAHrr_rot
    1388880635U,	// UXTB16r
    449356539U,	// UXTB16r_rot
    1388880642U,	// UXTBr
    449356546U,	// UXTBr_rot
    1388880647U,	// UXTHr
    449356551U,	// UXTHr_rot
    700736268U,	// tADC
    700883729U,	// tADDS
    700736273U,	// tADDhirr
    700883729U,	// tADDi3
    700736273U,	// tADDi8
    784335633U,	// tADDrPCi
    700883729U,	// tADDrSPi
    700883729U,	// tADDrr
    700810001U,	// tADDspi
    692060950U,	// tADJCALLSTACKDOWN
    692060971U,	// tADJCALLSTACKUP
    700736318U,	// tAND
    700883779U,	// tASRri
    700736323U,	// tASRrr
    692060221U,	// tB
    700736328U,	// tBIC
    805306436U,	// tBL
    805306440U,	// tBLXi
    692060232U,	// tBLXr
    788529997U,	// tBR_JTr
    692061014U,	// tBX
    870U,	// tBX_RET
    692061037U,	// tBX_RET_vararg
    981467262U,	// tBcc
    792723524U,	// tBfar
    700867441U,	// tCMN
    700867441U,	// tCMNNZ
    700867446U,	// tCMPNZi8
    700867446U,	// tCMPNZr
    700867446U,	// tCMPi8
    700867446U,	// tCMPr
    700736379U,	// tEOR
    702546816U,	// tLDR
    702677893U,	// tLDRB
    702808971U,	// tLDRH
    702940049U,	// tLDRSB
    702940056U,	// tLDRSH
    700867456U,	// tLDRcp
    700867456U,	// tLDRpci
    703071104U,	// tLDRspi
    2099904997U,	// tLEApcrel
    2104099301U,	// tLEApcrelJT
    700883871U,	// tLSLri
    700736415U,	// tLSLrr
    700883876U,	// tLSRri
    700736420U,	// tLSRrr
    423625641U,	// tMOVCCr
    700867508U,	// tMOVi8
    700867513U,	// tMOVr
    700736446U,	// tMUL
    700867523U,	// tMVN
    700867528U,	// tNEG
    700736461U,	// tORR
    2273312769U,	// tPICADD
    2415920082U,	// tPOP
    2415920082U,	// tPOP_RET
    2415920087U,	// tPUSH
    700867549U,	// tREV
    700867554U,	// tREV16
    700867561U,	// tREVSH
    700736496U,	// tROR
    703071104U,	// tRestore
    700736501U,	// tSBC
    702546938U,	// tSTR
    702678015U,	// tSTRB
    702809093U,	// tSTRH
    703071226U,	// tSTRspi
    700883979U,	// tSUBS
    700883979U,	// tSUBi3
    700736523U,	// tSUBi8
    700883979U,	// tSUBrr
    700810251U,	// tSUBspi
    700867600U,	// tSXTB
    700867606U,	// tSXTH
    703071226U,	// tSpill
    709U,	// tTPsoft
    700867612U,	// tTST
    700867617U,	// tUXTB
    700867623U,	// tUXTH
    0U
  };

  const char *AsmStrs = 
    "\000\000PHINODE\n\000adc\000add\000@ ADJCALLSTACKDOWN \000@ ADJCALLSTAC"
    "KUP \000and\000b \000bic\000bl \000blx \000bl\000add pc, \000ldr pc, \000"
    "mov pc, \000mov lr, pc\n\tbx \000bx\000b\000clz\000cmn\000cmp\000.loc \000"
    "eor\000fabsd\000fabss\000faddd\000fadds\000fcmped\000fcmpes\000fcmpezd\000"
    "fcmpezs\000fcpyd\000fcpys\000fcvtds\000fcvtsd\000fdivd\000fdivs\000fldd"
    "\000fldm\000flds\000fmacd\000fmacs\000fmdrr\000fmrrd\000fmrs\000fmscd\000"
    "fmscs\000fmsr\000fmstat\000fmuld\000fmuls\000fnegd\000fnegs\000fnmacd\000"
    "fnmacs\000fnmscd\000fnmscs\000fnmuld\000fnmuls\000fsitod\000fsitos\000f"
    "sqrtd\000fsqrts\000fstd\000fstm\000fsts\000fsubd\000fsubs\000ftosizd\000"
    "ftosizs\000ftouizd\000ftouizs\000fuitod\000fuitos\000ldm\000ldr\000.set"
    " PCRELV\000mla\000mov\000mul\000mvn\000orr\000pkhbt\000pkhtb\000rev\000"
    "rev16\000revsh\000rsb\000rsc\000sbc\000smlabb\000smlabt\000smlal\000sml"
    "atb\000smlatt\000smlawb\000smlawt\000smmla\000smmls\000smmul\000smulbb\000"
    "smulbt\000smull\000smultb\000smultt\000smulwb\000smulwt\000stm\000str\000"
    "sub\000sxtab\000sxtah\000sxtb\000sxth\000teq\000bl __aeabi_read_tp\n\000"
    "tst\000umaal\000umlal\000umull\000uxtab\000uxtah\000uxtb16\000uxtb\000u"
    "xth\000adc \000add \000@ tADJCALLSTACKDOWN \000@ tADJCALLSTACKUP \000an"
    "d \000asr \000bic \000cpy pc, \000cpy lr, pc\n\tbx \000bx lr\n\000bx \000"
    "cmn \000cmp \000eor \000ldr \000ldrb \000ldrh \000ldrsb \000ldrsh \000l"
    "sl \000lsr \000@ tMOVCCr \000mov \000cpy \000mul \000mvn \000neg \000or"
    "r \000pop \000push \000rev \000rev16 \000revsh \000ror \000sbc \000str "
    "\000strb \000strh \000sub \000sxtb \000sxth \000tst \000uxtb \000uxth \000";

  if (MI->getOpcode() == TargetInstrInfo::INLINEASM) {
    O << "\t";
    printInlineAsm(MI);
    return true;
  } else if (MI->isLabel()) {
    printLabel(MI);
    return true;
  } else if (MI->getOpcode() == TargetInstrInfo::DECLARE) {
    printDeclare(MI);
    return true;
  } else if (MI->getOpcode() == TargetInstrInfo::IMPLICIT_DEF) {
    printImplicitDef(MI);
    return true;
  }

  O << "\t";

  // Emit the opcode for the instruction.
  unsigned Bits = OpInfo[MI->getOpcode()];
  if (Bits == 0) return false;
  O << AsmStrs+(Bits & 2047);


  // Fragment 0 encoded into 5 bits for 19 unique commands.
  switch ((Bits >> 27) & 31) {
  default:   // unreachable.
  case 0:
    return true;
    break;
  case 1:
    // ADCri, ADCrr, RSCri, SBCri, SBCrr
    printSBitModifierOperand(MI, 3); 
    O << " "; 
    printOperand(MI, 0); 
    O << ", "; 
    printOperand(MI, 1); 
    O << ", "; 
    break;
  case 2:
    // ADCrs, RSCrs, SBCrs
    printSBitModifierOperand(MI, 5); 
    O << " "; 
    printOperand(MI, 0); 
    O << ", "; 
    printOperand(MI, 1); 
    O << ", "; 
    printSORegOperand(MI, 2); 
    O << "\n"; 
    return true;
    break;
  case 3:
    // ADDSri, ADDSrr, ADDri, ADDrr, ANDri, ANDrr, BICri, BICrr, EORri, EORrr...
    printPredicateOperand(MI, 3); 
    break;
  case 4:
    // ADDSrs, ADDrs, ANDrs, BICrs, EORrs, LDRB_POST, LDRB_PRE, LDRH_POST, LD...
    printPredicateOperand(MI, 5); 
    break;
  case 5:
    // ADJCALLSTACKDOWN, ADJCALLSTACKUP, B, BLX, BR_JTadd, BR_JTr, BX, tADC, ...
    printOperand(MI, 0); 
    break;
  case 6:
    // BL, tBL, tBLXi
    printOperand(MI, 0, "call"); 
    O << "\n"; 
    return true;
    break;
  case 7:
    // BL_pred, Bcc, FCMPEZD, FCMPEZS, tBcc
    printPredicateOperand(MI, 1); 
    O << " "; 
    break;
  case 8:
    // BR_JTm
    printAddrMode2Operand(MI, 0); 
    O << " \n"; 
    printJTBlockOperand(MI, 3); 
    O << "\n"; 
    return true;
    break;
  case 9:
    // BX_RET, FMSTAT
    printPredicateOperand(MI, 0); 
    break;
  case 10:
    // CLZ, CMNnzri, CMNnzrr, CMNri, CMNrr, CMPnzri, CMPnzrr, CMPri, CMPrr, F...
    printPredicateOperand(MI, 2); 
    break;
  case 11:
    // CMNnzrs, CMNrs, CMPnzrs, CMPrs, FMACD, FMACS, FMSCD, FMSCS, FNMACD, FN...
    printPredicateOperand(MI, 4); 
    break;
  case 12:
    // CONSTPOOL_ENTRY
    printCPInstOperand(MI, 0, "label"); 
    O << " "; 
    printCPInstOperand(MI, 1, "cpentry"); 
    O << "\n"; 
    return true;
    break;
  case 13:
    // DWARF_LOC
    printOperand(MI, 2); 
    O << ", "; 
    printOperand(MI, 0); 
    O << ", "; 
    printOperand(MI, 1); 
    O << "\n"; 
    return true;
    break;
  case 14:
    // FLDMD, FLDMS, FSTMD, FSTMS
    printAddrMode5Operand(MI, 0, "submode"); 
    break;
  case 15:
    // LEApcrel, LEApcrelJT, tLEApcrel, tLEApcrelJT
    PrintSpecial(MI, "uid"); 
    O << ", ("; 
    printOperand(MI, 1); 
    break;
  case 16:
    // PICADD, tPICADD
    printPCLabel(MI, 2); 
    break;
  case 17:
    // PICLDR, PICLDRB, PICLDRH, PICLDRSB, PICLDRSH, PICSTR, PICSTRB, PICSTRH
    printAddrModePCOperand(MI, 1, "label"); 
    break;
  case 18:
    // tPOP, tPOP_RET, tPUSH
    printRegisterList(MI, 0); 
    O << "\n"; 
    return true;
    break;
  }


  // Fragment 1 encoded into 5 bits for 31 unique commands.
  switch ((Bits >> 22) & 31) {
  default:   // unreachable.
  case 0:
    // ADCri, RSCri, SBCri
    printSOImmOperand(MI, 2); 
    O << "\n"; 
    return true;
    break;
  case 1:
    // ADCrr, SBCrr
    printOperand(MI, 2); 
    O << "\n"; 
    return true;
    break;
  case 2:
    // ADDSri, ADDSrr, ADDSrs, MOVsra_flag, MOVsrl_flag, RSBSri, RSBSrs, SUBS...
    O << "s "; 
    printOperand(MI, 0); 
    O << ", "; 
    printOperand(MI, 1); 
    break;
  case 3:
    // ADDri, ADDrr, ANDri, ANDrr, BICri, BICrr, EORri, EORrr, MUL, ORRri, OR...
    printSBitModifierOperand(MI, 5); 
    O << " "; 
    printOperand(MI, 0); 
    O << ", "; 
    printOperand(MI, 1); 
    O << ", "; 
    break;
  case 4:
    // ADDrs, ANDrs, BICrs, EORrs, ORRrs, RSBrs, SUBrs
    printSBitModifierOperand(MI, 7); 
    O << " "; 
    printOperand(MI, 0); 
    O << ", "; 
    printOperand(MI, 1); 
    O << ", "; 
    printSORegOperand(MI, 2); 
    O << "\n"; 
    return true;
    break;
  case 5:
    // ADJCALLSTACKDOWN, ADJCALLSTACKUP, B, BLX, BX, FMSTAT, tADJCALLSTACKDOW...
    O << "\n"; 
    return true;
    break;
  case 6:
    // BL_pred
    printOperand(MI, 0, "call"); 
    O << "\n"; 
    return true;
    break;
  case 7:
    // BR_JTadd, tADC, tADDS, tADDhirr, tADDi3, tADDi8, tADDrSPi, tADDrr, tAD...
    O << ", "; 
    break;
  case 8:
    // BR_JTr
    O << " \n"; 
    printJTBlockOperand(MI, 1); 
    O << "\n"; 
    return true;
    break;
  case 9:
    // BX_RET
    O << " lr\n"; 
    return true;
    break;
  case 10:
    // Bcc, FCMPEZD, FCMPEZS, tBcc
    printOperand(MI, 0); 
    O << "\n"; 
    return true;
    break;
  case 11:
    // CLZ, CMNnzri, CMNnzrr, CMNnzrs, CMNri, CMNrr, CMNrs, CMPnzri, CMPnzrr,...
    O << " "; 
    break;
  case 12:
    // FLDMD, FSTMD
    O << "d"; 
    printPredicateOperand(MI, 2); 
    O << " "; 
    printAddrMode5Operand(MI, 0, "base"); 
    O << ", "; 
    printRegisterList(MI, 4); 
    O << "\n"; 
    return true;
    break;
  case 13:
    // FLDMS, FSTMS
    O << "s"; 
    printPredicateOperand(MI, 2); 
    O << " "; 
    printAddrMode5Operand(MI, 0, "base"); 
    O << ", "; 
    printRegisterList(MI, 4); 
    O << "\n"; 
    return true;
    break;
  case 14:
    // LDM, LDM_RET, STM
    printAddrMode4Operand(MI, 0, "submode"); 
    O << " "; 
    printAddrMode4Operand(MI, 0); 
    O << ", "; 
    printRegisterList(MI, 4); 
    O << "\n"; 
    return true;
    break;
  case 15:
    // LDRB, LDRB_POST, LDRB_PRE, STRB, STRB_POST, STRB_PRE
    O << "b "; 
    break;
  case 16:
    // LDRD, STRD
    O << "d "; 
    printOperand(MI, 0); 
    O << ", "; 
    printAddrMode3Operand(MI, 1); 
    O << "\n"; 
    return true;
    break;
  case 17:
    // LDRH, LDRH_POST, LDRH_PRE, STRH, STRH_POST, STRH_PRE
    O << "h "; 
    break;
  case 18:
    // LDRSB, LDRSB_POST, LDRSB_PRE
    O << "sb "; 
    printOperand(MI, 0); 
    break;
  case 19:
    // LDRSH, LDRSH_POST, LDRSH_PRE
    O << "sh "; 
    printOperand(MI, 0); 
    break;
  case 20:
    // LEApcrel, tLEApcrel
    O << "-("; 
    PrintSpecial(MI, "private"); 
    O << "PCRELL"; 
    PrintSpecial(MI, "uid"); 
    break;
  case 21:
    // LEApcrelJT, tLEApcrelJT
    O << "_"; 
    printOperand(MI, 2, "no_hash"); 
    O << "-("; 
    PrintSpecial(MI, "private"); 
    O << "PCRELL"; 
    PrintSpecial(MI, "uid"); 
    break;
  case 22:
    // MLA, MOVs, MVNs, SMLAL, SMULL, UMLAL, UMULL
    printSBitModifierOperand(MI, 6); 
    O << " "; 
    printOperand(MI, 0); 
    O << ", "; 
    break;
  case 23:
    // MOVi, MOVr, MOVrx, MVNi, MVNr
    printSBitModifierOperand(MI, 4); 
    O << " "; 
    printOperand(MI, 0); 
    O << ", "; 
    break;
  case 24:
    // PICADD
    O << ":\n\tadd"; 
    printPredicateOperand(MI, 3); 
    O << " "; 
    printOperand(MI, 0); 
    O << ", pc, "; 
    printOperand(MI, 1); 
    O << "\n"; 
    return true;
    break;
  case 25:
    // PICLDR, PICLDRB, PICLDRH, PICLDRSB, PICLDRSH
    O << ":\n\tldr"; 
    printPredicateOperand(MI, 3); 
    break;
  case 26:
    // PICSTR, PICSTRB, PICSTRH
    O << ":\n\tstr"; 
    printPredicateOperand(MI, 3); 
    break;
  case 27:
    // tADDrPCi
    O << ", pc, "; 
    printOperand(MI, 1); 
    O << " * 4\n"; 
    return true;
    break;
  case 28:
    // tBR_JTr
    O << " \n\t.align\t2\n"; 
    printJTBlockOperand(MI, 1); 
    O << "\n"; 
    return true;
    break;
  case 29:
    // tBfar
    O << "\t@ far jump\n"; 
    return true;
    break;
  case 30:
    // tPICADD
    O << ":\n\tadd "; 
    printOperand(MI, 0); 
    O << ", pc\n"; 
    return true;
    break;
  }


  // Fragment 2 encoded into 5 bits for 22 unique commands.
  switch ((Bits >> 17) & 31) {
  default:   // unreachable.
  case 0:
    // ADDSri, ADDSrr, ADDSrs, LDRSB, LDRSB_PRE, LDRSH, LDRSH_PRE, RSBSri, RS...
    O << ", "; 
    break;
  case 1:
    // ADDri, ANDri, BICri, EORri, ORRri, RSBri, SUBri
    printSOImmOperand(MI, 2); 
    O << "\n"; 
    return true;
    break;
  case 2:
    // ADDrr, ANDrr, BICrr, EORrr, MUL, ORRrr, SUBrr, tADC, tADDhirr, tADDi8,...
    printOperand(MI, 2); 
    break;
  case 3:
    // BR_JTadd, MLA, MOVr, MOVrx, MVNr, SMLAL, SMULL, STRB_POST, STRB_PRE, S...
    printOperand(MI, 1); 
    break;
  case 4:
    // CLZ, CMNnzri, CMNnzrr, CMNnzrs, CMNri, CMNrr, CMNrs, CMPnzri, CMPnzrr,...
    printOperand(MI, 0); 
    break;
  case 5:
    // LDRSB_POST, LDRSH_POST
    O << ", ["; 
    printOperand(MI, 2); 
    O << "], "; 
    printAddrMode3OffsetOperand(MI, 3); 
    O << "\n"; 
    return true;
    break;
  case 6:
    // LEApcrel, LEApcrelJT
    O << "+8))\n"; 
    PrintSpecial(MI, "private"); 
    O << "PCRELL"; 
    PrintSpecial(MI, "uid"); 
    O << ":\n\tadd"; 
    break;
  case 7:
    // MOVi, MVNi
    printSOImmOperand(MI, 1); 
    O << "\n"; 
    return true;
    break;
  case 8:
    // MOVs, MVNs
    printSORegOperand(MI, 1); 
    O << "\n"; 
    return true;
    break;
  case 9:
    // MOVsra_flag
    O << ", asr #1\n"; 
    return true;
    break;
  case 10:
    // MOVsrl_flag
    O << ", lsr #1\n"; 
    return true;
    break;
  case 11:
    // PICLDR, PICSTR
    O << " "; 
    printOperand(MI, 0); 
    O << ", "; 
    printAddrModePCOperand(MI, 1); 
    O << "\n"; 
    return true;
    break;
  case 12:
    // PICLDRB, PICSTRB
    O << "b "; 
    printOperand(MI, 0); 
    O << ", "; 
    printAddrModePCOperand(MI, 1); 
    O << "\n"; 
    return true;
    break;
  case 13:
    // PICLDRH, PICSTRH
    O << "h "; 
    printOperand(MI, 0); 
    O << ", "; 
    printAddrModePCOperand(MI, 1); 
    O << "\n"; 
    return true;
    break;
  case 14:
    // PICLDRSB
    O << "sb "; 
    printOperand(MI, 0); 
    O << ", "; 
    printAddrModePCOperand(MI, 1); 
    O << "\n"; 
    return true;
    break;
  case 15:
    // PICLDRSH
    O << "sh "; 
    printOperand(MI, 0); 
    O << ", "; 
    printAddrModePCOperand(MI, 1); 
    O << "\n"; 
    return true;
    break;
  case 16:
    // tLDR, tSTR
    printThumbAddrModeS4Operand(MI, 1); 
    O << "\n"; 
    return true;
    break;
  case 17:
    // tLDRB, tSTRB
    printThumbAddrModeS1Operand(MI, 1); 
    O << "\n"; 
    return true;
    break;
  case 18:
    // tLDRH, tSTRH
    printThumbAddrModeS2Operand(MI, 1); 
    O << "\n"; 
    return true;
    break;
  case 19:
    // tLDRSB, tLDRSH
    printThumbAddrModeRROperand(MI, 1); 
    O << "\n"; 
    return true;
    break;
  case 20:
    // tLDRspi, tRestore, tSTRspi, tSpill
    printThumbAddrModeSPOperand(MI, 1); 
    O << "\n"; 
    return true;
    break;
  case 21:
    // tLEApcrel, tLEApcrelJT
    O << "+4))\n\tmov "; 
    printOperand(MI, 0); 
    O << ", #PCRELV"; 
    PrintSpecial(MI, "uid"); 
    O << "\n"; 
    PrintSpecial(MI, "private"); 
    O << "PCRELL"; 
    PrintSpecial(MI, "uid"); 
    O << ":\n\tadd "; 
    printOperand(MI, 0); 
    O << ", pc\n"; 
    return true;
    break;
  }


  // Fragment 3 encoded into 4 bits for 13 unique commands.
  switch ((Bits >> 13) & 15) {
  default:   // unreachable.
  case 0:
    // ADDSri, RSBSri, SUBSri
    printSOImmOperand(MI, 2); 
    O << "\n"; 
    return true;
    break;
  case 1:
    // ADDSrr, SUBSrr
    printOperand(MI, 2); 
    O << "\n"; 
    return true;
    break;
  case 2:
    // ADDSrs, RSBSrs, SUBSrs
    printSORegOperand(MI, 2); 
    O << "\n"; 
    return true;
    break;
  case 3:
    // ADDrr, ANDrr, BICrr, EORrr, MOVr, MUL, MVNr, ORRrr, SUBrr, tADC, tADDh...
    O << "\n"; 
    return true;
    break;
  case 4:
    // BR_JTadd
    O << " \n"; 
    printJTBlockOperand(MI, 2); 
    O << "\n"; 
    return true;
    break;
  case 5:
    // CLZ, CMNnzri, CMNnzrr, CMNnzrs, CMNri, CMNrr, CMNrs, CMPnzri, CMPnzrr,...
    O << ", "; 
    break;
  case 6:
    // LDRB_POST, LDRH_POST, LDR_POST, STRB_POST, STRB_PRE, STRH_POST, STRH_P...
    O << ", ["; 
    printOperand(MI, 2); 
    break;
  case 7:
    // LDRSB, LDRSH
    printAddrMode3Operand(MI, 1); 
    O << "\n"; 
    return true;
    break;
  case 8:
    // LDRSB_PRE, LDRSH_PRE
    printAddrMode3Operand(MI, 2); 
    O << "!\n"; 
    return true;
    break;
  case 9:
    // LEApcrel
    printPredicateOperand(MI, 2); 
    O << " "; 
    printOperand(MI, 0); 
    O << ", pc, #PCRELV"; 
    PrintSpecial(MI, "uid"); 
    O << "\n"; 
    return true;
    break;
  case 10:
    // LEApcrelJT
    printPredicateOperand(MI, 3); 
    O << " "; 
    printOperand(MI, 0); 
    O << ", pc, #PCRELV"; 
    PrintSpecial(MI, "uid"); 
    O << "\n"; 
    return true;
    break;
  case 11:
    // MOVrx
    O << ", rrx\n"; 
    return true;
    break;
  case 12:
    // tADDspi, tSUBspi
    O << " * 4\n"; 
    return true;
    break;
  }

  switch (MI->getOpcode()) {
  case ARM::CLZ:
  case ARM::CMNnzri:
  case ARM::CMNnzrr:
  case ARM::CMNnzrs:
  case ARM::CMNri:
  case ARM::CMNrr:
  case ARM::CMNrs:
  case ARM::CMPnzri:
  case ARM::CMPnzrr:
  case ARM::CMPnzrs:
  case ARM::CMPri:
  case ARM::CMPrr:
  case ARM::CMPrs:
  case ARM::FABSD:
  case ARM::FABSS:
  case ARM::FCMPED:
  case ARM::FCMPES:
  case ARM::FCPYD:
  case ARM::FCPYDcc:
  case ARM::FCPYS:
  case ARM::FCPYScc:
  case ARM::FCVTDS:
  case ARM::FCVTSD:
  case ARM::FLDD:
  case ARM::FLDS:
  case ARM::FMRS:
  case ARM::FMSR:
  case ARM::FNEGD:
  case ARM::FNEGDcc:
  case ARM::FNEGS:
  case ARM::FNEGScc:
  case ARM::FSITOD:
  case ARM::FSITOS:
  case ARM::FSQRTD:
  case ARM::FSQRTS:
  case ARM::FSTD:
  case ARM::FSTS:
  case ARM::FTOSIZD:
  case ARM::FTOSIZS:
  case ARM::FTOUIZD:
  case ARM::FTOUIZS:
  case ARM::FUITOD:
  case ARM::FUITOS:
  case ARM::LDR:
  case ARM::LDRB:
  case ARM::LDRH:
  case ARM::LDRcp:
  case ARM::MOVCCi:
  case ARM::MOVCCr:
  case ARM::MOVCCs:
  case ARM::MOVi2pieces:
  case ARM::REV:
  case ARM::REV16:
  case ARM::REVSH:
  case ARM::STR:
  case ARM::STRB:
  case ARM::STRH:
  case ARM::SXTBr:
  case ARM::SXTHr:
  case ARM::TEQri:
  case ARM::TEQrr:
  case ARM::TEQrs:
  case ARM::TSTri:
  case ARM::TSTrr:
  case ARM::TSTrs:
  case ARM::UXTB16r:
  case ARM::UXTBr:
  case ARM::UXTHr:
  case ARM::tADDS:
  case ARM::tADDi3:
  case ARM::tADDrr:
  case ARM::tASRri:
  case ARM::tLSLri:
  case ARM::tLSRri:
  case ARM::tSUBS:
  case ARM::tSUBi3:
  case ARM::tSUBrr:
    switch (MI->getOpcode()) {
    case ARM::CLZ: 
    case ARM::CMNnzrr: 
    case ARM::CMNrr: 
    case ARM::CMPnzrr: 
    case ARM::CMPrr: 
    case ARM::FABSD: 
    case ARM::FABSS: 
    case ARM::FCMPED: 
    case ARM::FCMPES: 
    case ARM::FCPYD: 
    case ARM::FCPYS: 
    case ARM::FCVTDS: 
    case ARM::FCVTSD: 
    case ARM::FMRS: 
    case ARM::FMSR: 
    case ARM::FNEGD: 
    case ARM::FNEGS: 
    case ARM::FSITOD: 
    case ARM::FSITOS: 
    case ARM::FSQRTD: 
    case ARM::FSQRTS: 
    case ARM::FTOSIZD: 
    case ARM::FTOSIZS: 
    case ARM::FTOUIZD: 
    case ARM::FTOUIZS: 
    case ARM::FUITOD: 
    case ARM::FUITOS: 
    case ARM::REV: 
    case ARM::REV16: 
    case ARM::REVSH: 
    case ARM::SXTBr: 
    case ARM::SXTHr: 
    case ARM::TEQrr: 
    case ARM::TSTrr: 
    case ARM::UXTB16r: 
    case ARM::UXTBr: 
    case ARM::UXTHr: printOperand(MI, 1); break;
    case ARM::CMNnzri: 
    case ARM::CMNri: 
    case ARM::CMPnzri: 
    case ARM::CMPri: 
    case ARM::TEQri: 
    case ARM::TSTri: printSOImmOperand(MI, 1); break;
    case ARM::CMNnzrs: 
    case ARM::CMNrs: 
    case ARM::CMPnzrs: 
    case ARM::CMPrs: 
    case ARM::TEQrs: 
    case ARM::TSTrs: printSORegOperand(MI, 1); break;
    case ARM::FCPYDcc: 
    case ARM::FCPYScc: 
    case ARM::FNEGDcc: 
    case ARM::FNEGScc: 
    case ARM::MOVCCr: 
    case ARM::tADDS: 
    case ARM::tADDi3: 
    case ARM::tADDrr: 
    case ARM::tASRri: 
    case ARM::tLSLri: 
    case ARM::tLSRri: 
    case ARM::tSUBS: 
    case ARM::tSUBi3: 
    case ARM::tSUBrr: printOperand(MI, 2); break;
    case ARM::FLDD: 
    case ARM::FLDS: 
    case ARM::FSTD: 
    case ARM::FSTS: printAddrMode5Operand(MI, 1); break;
    case ARM::LDR: 
    case ARM::LDRB: 
    case ARM::LDRcp: 
    case ARM::STR: 
    case ARM::STRB: printAddrMode2Operand(MI, 1); break;
    case ARM::LDRH: 
    case ARM::STRH: printAddrMode3Operand(MI, 1); break;
    case ARM::MOVCCi: printSOImmOperand(MI, 2); break;
    case ARM::MOVCCs: printSORegOperand(MI, 2); break;
    case ARM::MOVi2pieces: printSOImm2PartOperand(MI, 1); break;
    }
    O << "\n"; 
    break;
  case ARM::FADDD:
  case ARM::FADDS:
  case ARM::FDIVD:
  case ARM::FDIVS:
  case ARM::FMDRR:
  case ARM::FMRRD:
  case ARM::FMULD:
  case ARM::FMULS:
  case ARM::FNMULD:
  case ARM::FNMULS:
  case ARM::FSUBD:
  case ARM::FSUBS:
  case ARM::SMMUL:
  case ARM::SMULBB:
  case ARM::SMULBT:
  case ARM::SMULTB:
  case ARM::SMULTT:
  case ARM::SMULWB:
  case ARM::SMULWT:
  case ARM::SXTABrr:
  case ARM::SXTAHrr:
  case ARM::SXTBr_rot:
  case ARM::SXTHr_rot:
  case ARM::UXTABrr:
  case ARM::UXTAHrr:
  case ARM::UXTB16r_rot:
  case ARM::UXTBr_rot:
  case ARM::UXTHr_rot:
    printOperand(MI, 1); 
    switch (MI->getOpcode()) {
    case ARM::FADDD: 
    case ARM::FADDS: 
    case ARM::FDIVD: 
    case ARM::FDIVS: 
    case ARM::FMDRR: 
    case ARM::FMRRD: 
    case ARM::FMULD: 
    case ARM::FMULS: 
    case ARM::FNMULD: 
    case ARM::FNMULS: 
    case ARM::FSUBD: 
    case ARM::FSUBS: 
    case ARM::SMMUL: 
    case ARM::SMULBB: 
    case ARM::SMULBT: 
    case ARM::SMULTB: 
    case ARM::SMULTT: 
    case ARM::SMULWB: 
    case ARM::SMULWT: 
    case ARM::SXTABrr: 
    case ARM::SXTAHrr: 
    case ARM::UXTABrr: 
    case ARM::UXTAHrr: O << ", "; break;
    case ARM::SXTBr_rot: 
    case ARM::SXTHr_rot: 
    case ARM::UXTB16r_rot: 
    case ARM::UXTBr_rot: 
    case ARM::UXTHr_rot: O << ", ror "; break;
    }
    printOperand(MI, 2); 
    O << "\n"; 
    break;
  case ARM::FMACD:
  case ARM::FMACS:
  case ARM::FMSCD:
  case ARM::FMSCS:
  case ARM::FNMACD:
  case ARM::FNMACS:
  case ARM::FNMSCD:
  case ARM::FNMSCS:
  case ARM::MLA:
  case ARM::SMLAL:
  case ARM::SMULL:
  case ARM::UMLAL:
  case ARM::UMULL:
    printOperand(MI, 2); 
    O << ", "; 
    printOperand(MI, 3); 
    O << "\n"; 
    break;
  case ARM::LDRB_POST:
  case ARM::LDRH_POST:
  case ARM::LDR_POST:
  case ARM::STRB_POST:
  case ARM::STRH_POST:
  case ARM::STR_POST:
    O << "], "; 
    switch (MI->getOpcode()) {
    case ARM::LDRB_POST: 
    case ARM::LDR_POST: 
    case ARM::STRB_POST: 
    case ARM::STR_POST: printAddrMode2OffsetOperand(MI, 3); break;
    case ARM::LDRH_POST: 
    case ARM::STRH_POST: printAddrMode3OffsetOperand(MI, 3); break;
    }
    O << "\n"; 
    break;
  case ARM::LDRB_PRE:
  case ARM::LDRH_PRE:
  case ARM::LDR_PRE:
    switch (MI->getOpcode()) {
    case ARM::LDRB_PRE: 
    case ARM::LDR_PRE: printAddrMode2Operand(MI, 2); break;
    case ARM::LDRH_PRE: printAddrMode3Operand(MI, 2); break;
    }
    O << "!\n"; 
    break;
  case ARM::PKHBT:
  case ARM::PKHTB:
  case ARM::SMLABB:
  case ARM::SMLABT:
  case ARM::SMLATB:
  case ARM::SMLATT:
  case ARM::SMLAWB:
  case ARM::SMLAWT:
  case ARM::SMMLA:
  case ARM::SMMLS:
  case ARM::SXTABrr_rot:
  case ARM::SXTAHrr_rot:
  case ARM::UMAAL:
  case ARM::UXTABrr_rot:
  case ARM::UXTAHrr_rot:
    printOperand(MI, 1); 
    O << ", "; 
    printOperand(MI, 2); 
    switch (MI->getOpcode()) {
    case ARM::PKHBT: O << ", LSL "; break;
    case ARM::PKHTB: O << ", ASR "; break;
    case ARM::SMLABB: 
    case ARM::SMLABT: 
    case ARM::SMLATB: 
    case ARM::SMLATT: 
    case ARM::SMLAWB: 
    case ARM::SMLAWT: 
    case ARM::SMMLA: 
    case ARM::SMMLS: 
    case ARM::UMAAL: O << ", "; break;
    case ARM::SXTABrr_rot: 
    case ARM::SXTAHrr_rot: 
    case ARM::UXTABrr_rot: 
    case ARM::UXTAHrr_rot: O << ", ror "; break;
    }
    printOperand(MI, 3); 
    O << "\n"; 
    break;
  case ARM::STRB_PRE:
  case ARM::STRH_PRE:
  case ARM::STR_PRE:
    O << ", "; 
    switch (MI->getOpcode()) {
    case ARM::STRB_PRE: 
    case ARM::STR_PRE: printAddrMode2OffsetOperand(MI, 3); break;
    case ARM::STRH_PRE: printAddrMode3OffsetOperand(MI, 3); break;
    }
    O << "]!\n"; 
    break;
  case ARM::tADDrSPi:
    printOperand(MI, 2); 
    O << " * 4\n"; 
    break;
  }
  return true;
}
